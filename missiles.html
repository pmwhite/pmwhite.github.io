<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Missiles</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 100%;
    }
    #game {
      display: block;
      background: #fff;
      width: 100%;
      height: 100dvh;
      margin: auto;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1000" height="500"></canvas>

  <script>
    const stone800 = '#292524';
    const stone700 = '#44403c';
    const red950 = '#450a0a';
    const red400 = '#f87171';
    const red700 = '#b91c1c';
    const yellow500 = '#eab308';
    const neutral300 = '#d4d4d4';
    const lime200 = '#d9f99d';
    const teal200 = '#99f6e4';
    const blue200 = '#bfdbfe';
    const indigo200 = '#c7d2fe';
    const color__background = stone800;
    const color__ground = stone700;
    const color__interceptor_slot = red950;
    const color__interceptor_target = red400;
    const color__interceptor = red700;
    const color__missile = yellow500;
    const color__text = neutral300;
    const color__explosion = [ lime200, teal200, blue200, indigo200 ];
    function random_explosion_color() {
      return color__explosion[Math.floor(Math.random() * color__explosion.length)];
    }

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let size = 500;
    let x_offset = 0;
    let y_offset = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      size = Math.min(canvas.width, canvas.height);
      x_offset = (canvas.width - size) / 2;
      y_offset = (canvas.height - size) / 2;
    }

    window.addEventListener('resize', resize);
    resize();

    let score = 0;
    const interceptor_cost = 1;
    const missile_intercept_gain = 5;
    const interceptor_slot_alive_at_wave_end_gain = 20;
    const level_summary_duration = 10000;

    let missiles = new Map();
    let missile_spawn_period = 3000;
    let missile_velocity = 1 / 20000;
    let missiles_spawned = 0;
    let missiles_spawned_at_wave_start = 0;
    let waves = [
      { count: 10, period: 1000 },
      { count: 15, period: 500 },
      { count: 50, period: 450 },
      { count: 50, period: 200 },
      { count: 50, period: 500 },
    ];
    let current_wave = 0;
    let current_wave_started_at = 0;
    let current_wave_finished = false;
    let current_wave_finished_at = 0;
    let current_wave_missiles_intercepted = 0;
    let current_wave_interceptor_slots_alive_at_end = 0;

    let interceptors = new Map();
    let interceptor_slot_reload_period = 3000;
    let interceptor_velocity = 6 / 20000;
    let interceptors_spawned = 0;
    let interceptors_spawned_at_wave_start = 0;
    let interceptor_slot_count = 6;
    let interceptor_slots = [];
    for (let i = 0; i < interceptor_slot_count; i++) {
      interceptor_slots.push({
        x: (i + 0.5) / (interceptor_slot_count),
        last_used_at: -interceptor_slot_reload_period,
        alive: true,
        destroyed_at: 0
      });
    }

    let explosions = new Map();
    let explosions_spawned = 0;
    let explosion_radius = 30 / 1000;
    let explosion_duration = 5000;

    let marker_radius = 5 / 1000;
    let ground_height = 0.03;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    let mouse_down_time = 0;
    let mouse_is_down = false;
    let mouse_x = 0;
    let mouse_y = 0;

    document.addEventListener('contextmenu', event => event.preventDefault());

    canvas.addEventListener('pointerdown', ev => {
      mouse_is_down = true;
      mouse_down_time = performance.now();
      mouse_x = (ev.clientX - x_offset) / size;
      mouse_y = (ev.clientY - y_offset) / size;
      interceptors_spawned_during_strafe = 0;
      ev.preventDefault();
    });

    canvas.addEventListener('pointermove', ev => {
      mouse_x = (ev.clientX - x_offset) / size;
      mouse_y = (ev.clientY - y_offset) / size;
      ev.preventDefault();
    });

    canvas.addEventListener('pointerup', ev => {
      mouse_is_down = false;
      ev.preventDefault();
    });

    function frame() {
      const now = performance.now();
      const missile_spawn_t = now - current_wave_started_at;
      if (!current_wave_finished && current_wave < waves.length) {
        const wave = waves[current_wave];
        const missiles_spawned_during_wave = missiles_spawned - missiles_spawned_at_wave_start;
        const expected_missiles = Math.max(0, Math.min(wave.count, Math.ceil(missile_spawn_t / wave.period)));
        const new_missiles_to_spawn = expected_missiles - missiles_spawned_during_wave;
        for (let i = 0; i < new_missiles_to_spawn; i++) {
          missiles.set(missiles_spawned, { spawn_time: now, start: Math.random(), end: Math.random() });
          missiles_spawned++;
        }
        if (missiles_spawned_during_wave === wave.count && missiles.size === 0 && explosions.size === 0) {
          current_wave_finished = true;
          current_wave_finished_at = now;
          current_wave_interceptor_slots_alive_at_end = 0;
          for (const interceptor_slot of interceptor_slots) {
            if (interceptor_slot.alive) {
              current_wave_interceptor_slots_alive_at_end++;
            }
          }
          score += current_wave_interceptor_slots_alive_at_end * interceptor_slot_alive_at_wave_end_gain;
        }
      }

      if (current_wave_finished && now - current_wave_finished_at > level_summary_duration) {
        current_wave++;
        current_wave_finished = false;
        current_wave_started_at = now;
        missiles_spawned_at_wave_start = missiles_spawned;
        interceptors_spawned_at_wave_start = interceptors_spawned;
        current_wave_missiles_intercepted = 0;
      }

      if (mouse_is_down) {
        let alive_interceptor_slot_count = 0;
        for (const interceptor_slot of interceptor_slots) {
          if (interceptor_slot.alive) {
            alive_interceptor_slot_count++;
          }
        }
        let interceptor_spawn_period = interceptor_slot_reload_period / alive_interceptor_slot_count;
        const new_interceptors_to_spawn = Math.floor((now - mouse_down_time) / interceptor_spawn_period) - interceptors_spawned_during_strafe + 1;
        for (let i = 0; i < new_interceptors_to_spawn; i++) {
          let closest_interceptor_slot = interceptor_slots[0];
          for (const next_interceptor_slot of interceptor_slots) {
            if (next_interceptor_slot.alive
              && now - next_interceptor_slot.last_used_at > interceptor_slot_reload_period
              && (!closest_interceptor_slot.alive
                 || now - closest_interceptor_slot.last_used_at <= interceptor_slot_reload_period
                 || Math.abs(next_interceptor_slot.x - mouse_x) < Math.abs(closest_interceptor_slot.x - mouse_x))) {
              closest_interceptor_slot = next_interceptor_slot;
            }
          }
          if (closest_interceptor_slot.alive && now - closest_interceptor_slot.last_used_at > interceptor_slot_reload_period) {
            closest_interceptor_slot.last_used_at = now;
            interceptors.set(interceptors_spawned, { spawn_time: now, target_x: mouse_x, target_y: mouse_y, start_x: closest_interceptor_slot.x });
            score -= interceptor_cost;
            interceptors_spawned++;
            interceptors_spawned_during_strafe++;
          }
        }
      }

      for (const [ id, explosion ] of explosions) {
        const t = (now - explosion.spawn_time) / explosion_duration + 0.1;
        const radius = Math.sin(t * Math.PI) * explosion_radius;

        if (t > 1) {
          explosions.delete(id);
        }

        explosion.radius = radius;
      }


      for (const [ id, missile ] of missiles) {
        const end_start_diff = missile.end - missile.start;
        const length = Math.sqrt(1 + end_start_diff * end_start_diff);
        const t = (now - missile.spawn_time) / length * missile_velocity;
        const x = lerp(missile.start, missile.end, t);
        const y = lerp(0, 1 - ground_height, t);

        let should_explode = t > 1;
        if (!should_explode) {
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              should_explode = true;
              score += missile_intercept_gain;
              current_wave_missiles_intercepted += 1;
              break;
            }
          }
        }

        if (should_explode) {
          missiles.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
          explosions_spawned++;
        }

        missile.x = x;
        missile.y = y;
      }

      for (const [ id, interceptor ] of interceptors) {
        const x1 = interceptor.start_x;
        const y1 = 1 - ground_height;
        const x2 = interceptor.target_x;
        const y2 = interceptor.target_y;
        const x_diff = x1 - x2;
        const y_diff = y1 - y2;
        const length = Math.sqrt(y_diff * y_diff + x_diff * x_diff);
        const t = (now - interceptor.spawn_time) / length * interceptor_velocity;
        const x = lerp(x1, x2, t);
        const y = lerp(y1, y2, t);

        if (t > 1) {
          interceptors.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
          explosions_spawned++;
        }

        interceptor.x = x;
        interceptor.y = y;
      }

      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive) {
          const x = interceptor_slot.x;
          const y = 1 - ground_height;
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
              explosions_spawned++;
              interceptor_slot.alive = false;
              interceptor_slot.destroyed_at = now;
              break;
            }
          }
        }
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = 'gray';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.translate(x_offset, y_offset);

      ctx.fillStyle = color__background;
      ctx.fillRect(0, 0, size, size);

      ctx.fillStyle = color__ground;
      ctx.fillRect(0, (1 - ground_height) * size, size, ground_height * size);

      ctx.lineWidth = 2;

      ctx.strokeStyle = color__missile;
      ctx.beginPath();
      for (const missile of missiles.values()) {
        ctx.moveTo(missile.start * size, 0);
        ctx.lineTo(missile.x * size, missile.y * size);
      }
      ctx.stroke();

      ctx.fillStyle = color__interceptor;
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        ctx.arc(interceptor.x * size, interceptor.y * size, marker_radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = color__interceptor_slot;
      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive || now - interceptor_slot.destroyed_at < explosion_duration / 2) {
          ctx.beginPath();
          ctx.fillRect(interceptor_slot.x * size - marker_radius * size, (1 - ground_height) * size, marker_radius * size * 2, ground_height * size);
          ctx.fill();
        }
      }

      ctx.fillStyle = color__interceptor;
      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive) {
          let offset = Math.max(0, (interceptor_slot_reload_period - now + interceptor_slot.last_used_at) / interceptor_slot_reload_period * ground_height);
          ctx.beginPath();
          ctx.arc(interceptor_slot.x * size, ((1 - ground_height) + offset) * size, marker_radius * size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      ctx.globalAlpha = 0.5;
      for (const explosion of explosions.values()) {
        ctx.fillStyle = explosion.color;
        const x = explosion.x * size;
        const y = explosion.y * size;
        ctx.beginPath();
        ctx.arc(x, y, explosion.radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.strokeStyle = color__interceptor_target;
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        const x = interceptor.target_x * size;
        const y = interceptor.target_y * size;
        const diff = size * 0.01;
        ctx.moveTo(x - diff, y - diff);
        ctx.lineTo(x + diff, y + diff);
        ctx.moveTo(x + diff, y - diff);
        ctx.lineTo(x - diff, y + diff);
        ctx.stroke();
      }

      ctx.fillStyle = color__text;
      ctx.font = `bold 15px monospace`;
      ctx.globalAlpha = 0.5;
      ctx.fillText(` wave: ${current_wave + 1}`, 5, 15);
      ctx.fillText(`score: ${score}`, 5, 30);
      ctx.globalAlpha = 1;

      if (current_wave_finished && now - current_wave_finished_at < level_summary_duration) {
        const fired = interceptors_spawned - interceptors_spawned_at_wave_start;
        const level_score = fired * -interceptor_cost +
          current_wave_missiles_intercepted * missile_intercept_gain +
          current_wave_interceptor_slots_alive_at_end * interceptor_slot_alive_at_wave_end_gain;
        let line1 = `wave ${current_wave + 1} finished`;
        let line3 = `fired:       ${fired} x -${interceptor_cost} each`;
        let line4 = `blocked:     ${current_wave_missiles_intercepted} x ${missile_intercept_gain} each`;
        let line5 = `towers left: ${current_wave_interceptor_slots_alive_at_end} x ${interceptor_slot_alive_at_wave_end_gain} each`;
        let line7 = `level score: ${level_score}`;
        let line8 = `total score: ${score}`;
        let content_lines = [ line1, line3, line4, line5, line7, line8 ];

        let width = size;
        let characters = 0;
        let font_size_px = 30;
        for (; width > 0.8 * size; font_size_px--) {
          ctx.font = `${font_size_px}px monospace`;
          width = 0;
          for (const line of content_lines) {
            const candidate_width = ctx.measureText(line).width;
            if (candidate_width > width) {
              width = candidate_width;
              characters = line.length;
            }
          }
        }

        const lines = [
          line1,
          '='.repeat(characters),
          line3,
          line4,
          line5,
          '-'.repeat(characters),
          line7,
          line8
        ];

        const x = 0.5 * size - width / 2;
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, 0.5 * size + i * font_size_px - (lines.length * (font_size_px / 2)));
        }

        const loading_bar_width = Math.max(0, (level_summary_duration - (now - current_wave_finished_at)) / level_summary_duration) * width;
        ctx.fillRect(x, 0.5 * size + lines.length * (font_size_px / 2) - font_size_px / 2, loading_bar_width, font_size_px);
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
