<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Missiles</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 100%;
    }
    #game {
      display: block;
      background: #fff;
      width: 100%;
      height: 100dvh;
      margin: auto;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1000" height="500"></canvas>

  <script>
    const stone800 = '#292524';
    const stone700 = '#44403c';
    const red950 = '#450a0a';
    const red400 = '#f87171';
    const red700 = '#b91c1c';
    const yellow500 = '#eab308';
    const yellow300 = '#fde047';
    const neutral300 = '#d4d4d4';
    const lime200 = '#d9f99d';
    const teal200 = '#99f6e4';
    const blue200 = '#bfdbfe';
    const indigo200 = '#c7d2fe';
    const color__background = stone800;
    const color__ground = stone700;
    const color__interceptor_slot = red950;
    const color__interceptor_target = red400;
    const color__interceptor = red700;
    const color__missile = yellow500;
    const color__bomb = yellow300;
    const color__text = neutral300;
    const color__explosion = [ lime200, teal200, blue200, indigo200 ];

    function random_explosion_color() {
      return color__explosion[Math.floor(Math.random() * color__explosion.length)];
    }

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let size = 500;
    let x_offset = 0;
    let y_offset = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      size = Math.min(canvas.width, canvas.height);
      x_offset = (canvas.width - size) / 2;
      y_offset = (canvas.height - size) / 2;
    }

    window.addEventListener('resize', resize);
    resize();

    let score = 0;
    const interceptor_cost = 1;
    const missile_intercept_gain = 1;
    const bomb_intercept_gain = 5;
    const interceptor_slot_alive_at_wave_end_gain = 5;
    const level_summary_duration = 10000;

    let bombs = new Map();
    let bomb_period = 2 / 20000;
    let bombs_spawned = 0;
    let bombs_spawned_at_wave_start = 0;
    let bomb_size = 10 / 1000;

    let missiles = new Map();
    let missile_velocity = 1 / 20000;
    let missiles_spawned = 0;
    let missiles_spawned_at_wave_start = 0;
    let waves = [
      { count: 10, period: 1000, bomb_count: 0, bomb_period: 1000 },
      { count: 15, period: 500, bomb_count: 0, bomb_period: 1000 },
      { count: 10, period: 1000, bomb_count: 3, bomb_period: 4000 },
      { count: 50, period: 450, bomb_count: 2, bomb_period: 10000 },
      { count: 50, period: 200, bomb_count: 0, bomb_period: 1000 },
      { count: 50, period: 500, bomb_count: 3, bomb_period: 10000 },
      { count: 20, period: 100, bomb_count: 0, bomb_period: 1000 },
      { count: 30, period: 1000, bomb_count: 10, bomb_period: 3000 },
    ];
    let current_wave = 0;
    let current_wave_started_at = 0;
    let current_wave_finished = false;
    let current_wave_finished_at = 0;
    let current_wave_missiles_intercepted = 0;
    let current_wave_bombs_intercepted = 0;
    let current_wave_interceptor_slots_alive_at_end = 0;
    let game_lost = false;

    let interceptors = new Map();
    let interceptor_slot_reload_period = 3000;
    let interceptor_slot_shift_period = 250;
    let interceptor_velocity = 6 / 20000;
    let interceptors_spawned = 0;
    let interceptors_spawned_at_wave_start = 0;
    let interceptor_slot_count = 6;
    let interceptor_slots = [];
    for (let i = 0; i < interceptor_slot_count; i++) {
      interceptor_slots.push({
        x: (i + 0.5) / (interceptor_slot_count),
        bullet_fire_times: Array(3).fill(-interceptor_slot_reload_period),
        bullet_index_snapshot: 0,
        bullet_index_snapshot_at: 0,
        next_bullet_index: 0,
        alive: true,
        destroyed_at: 0
      });
    }

    let explosions = new Map();
    let explosions_spawned = 0;
    let explosion_radius = 30 / 1000;
    let explosion_duration = 5000;

    let marker_radius = 5 / 1000;
    let ground_height = 0.03;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    document.addEventListener('contextmenu', event => event.preventDefault());

    function interceptor_slot_bullet_index_snapshot(slot, now) {
      return Math.min(slot.next_bullet_index, lerp(slot.bullet_index_snapshot, slot.next_bullet_index, (now - slot.bullet_index_snapshot_at) / interceptor_slot_shift_period));
    }

    canvas.addEventListener('pointerdown', ev => {
      if (!current_wave_finished) {
        const now = performance.now();
        const mouse_x = (ev.clientX - x_offset) / size;
        const mouse_y = (ev.clientY - y_offset) / size;
        let alive_interceptor_slot_count = 0;
        for (const interceptor_slot of interceptor_slots) {
          if (interceptor_slot.alive) {
            alive_interceptor_slot_count++;
          }
        }
        let closest_interceptor_slot = null;
        let bullet_to_fire_index = 0;
        for (const next_interceptor_slot of interceptor_slots) {
          if (next_interceptor_slot.alive && (closest_interceptor_slot === null || Math.abs(next_interceptor_slot.x - mouse_x) < Math.abs(closest_interceptor_slot.x - mouse_x))) {
            let next_interceptor_slot_is_firable = false;
            let max_bullet_wait_time = 0;
            for (let i = 0; i < next_interceptor_slot.bullet_fire_times.length; i++) {
              let bullet_wait_time = now - next_interceptor_slot.bullet_fire_times[i];
              if (bullet_wait_time > interceptor_slot_reload_period && bullet_wait_time > max_bullet_wait_time) {
                next_interceptor_slot_is_firable = true;
                bullet_to_fire_index = i;
                max_bullet_wait_time = bullet_wait_time;
              }
            }
            if (next_interceptor_slot_is_firable) {
              closest_interceptor_slot = next_interceptor_slot;
            }
          }
        }
        if (closest_interceptor_slot !== null) {
          closest_interceptor_slot.bullet_fire_times[bullet_to_fire_index] = now;
          const bullet_fire_time = 
          closest_interceptor_slot.bullet_index_snapshot = interceptor_slot_bullet_index_snapshot(closest_interceptor_slot, now);
          closest_interceptor_slot.bullet_index_snapshot_at = now;
          closest_interceptor_slot.next_bullet_index++;
          interceptors.set(interceptors_spawned, { spawn_time: now, target_x: mouse_x, target_y: mouse_y, start_x: closest_interceptor_slot.x });
          score -= interceptor_cost;
          interceptors_spawned++;
        }
      }
      ev.preventDefault();
    });

    function frame() {
      const now = performance.now();
      const wave_t = now - current_wave_started_at;

      let interceptor_slots_alive = 0;
      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive) {
          interceptor_slots_alive++;
        }
      }
      if (interceptor_slots_alive === 0) {
        game_lost = true;
      }

      if (!current_wave_finished && !game_lost) {
        const wave = waves[current_wave];

        const missiles_spawned_during_wave = missiles_spawned - missiles_spawned_at_wave_start;
        const expected_missiles = Math.max(0, Math.min(wave.count, Math.ceil(wave_t / wave.period)));
        const new_missiles_to_spawn = expected_missiles - missiles_spawned_during_wave;
        for (let i = 0; i < new_missiles_to_spawn; i++) {
          missiles.set(missiles_spawned, { spawn_time: now, start: Math.random(), end: Math.random() });
          missiles_spawned++;
        }

        const bombs_spawned_during_wave = bombs_spawned - bombs_spawned_at_wave_start;
        const expected_bombs = Math.max(0, Math.min(wave.bomb_count, Math.ceil(wave_t / wave.bomb_period)));
        const new_bombs_to_spawn = expected_bombs - bombs_spawned_during_wave;
        for (let i = 0; i < new_bombs_to_spawn; i++) {
          const weights = [];
          for (let w = 0; w < 10; w++) {
            weights[w] = Math.random();
          }
          bombs.set(bombs_spawned, { spawn_time: now, weights: weights });
          bombs_spawned++;
        }

        if (missiles_spawned_during_wave === wave.count 
          && missiles.size === 0 
          && bombs_spawned_during_wave === wave.bomb_count 
          && bombs.size === 0 
          && explosions.size === 0) {

          current_wave_finished = true;
          current_wave_finished_at = now;
          current_wave_interceptor_slots_alive_at_end = 0;
          for (const interceptor_slot of interceptor_slots) {
            if (interceptor_slot.alive) {
              current_wave_interceptor_slots_alive_at_end++;
            }
          }
          score += current_wave_interceptor_slots_alive_at_end * interceptor_slot_alive_at_wave_end_gain;
        }
      }

      if (current_wave_finished && now - current_wave_finished_at > level_summary_duration && current_wave < waves.length - 1) {
        current_wave++;
        current_wave_finished = false;
        current_wave_started_at = now;
        missiles_spawned_at_wave_start = missiles_spawned;
        bombs_spawned_at_wave_start = bombs_spawned;
        interceptors_spawned_at_wave_start = interceptors_spawned;
        current_wave_missiles_intercepted = 0;
        current_wave_bombs_intercepted = 0;
      }

      for (const [ id, explosion ] of explosions) {
        const t = (now - explosion.spawn_time) / explosion_duration + 0.1;
        const radius = Math.sin(t * Math.PI) * explosion_radius;

        if (t > 1) {
          explosions.delete(id);
        }

        explosion.radius = radius;
      }

      for (const [ id, missile ] of missiles) {
        const end_start_diff = missile.end - missile.start;
        const length = Math.sqrt(1 + end_start_diff * end_start_diff);
        const t = (now - missile.spawn_time) / length * missile_velocity;
        const x = lerp(missile.start, missile.end, t);
        const y = lerp(0, 1 - ground_height, t);

        let should_explode = t > 1;
        if (!should_explode) {
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              should_explode = true;
              if (!game_lost) {
                score += missile_intercept_gain;
                current_wave_missiles_intercepted += 1;
              }
              break;
            }
          }
        }

        if (should_explode) {
          missiles.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
          explosions_spawned++;
        }

        missile.x = x;
        missile.y = y;
      }

      const bomb_base_weights = [ 1, 9, 36, 84, 126, 126, 84, 36, 9, 1 ];
      for (const [ id, bomb ] of bombs) {
        const t = (now - bomb.spawn_time) * bomb_period;
        let x = 0;
        for (let i = 0; i < bomb.weights.length; i++) {
          x += bomb.weights[i] * bomb_base_weights[i] * Math.pow(t, i) * Math.pow(1 - t, bomb.weights.length - 1 - i);
        }
        const y = lerp(0, 1 - ground_height, t);

        let should_explode = t > 1;
        if (!should_explode) {
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              should_explode = true;
              if (!game_lost) {
                score += bomb_intercept_gain;
                current_wave_bombs_intercepted += 1;
              }
              break;
            }
          }
        }

        if (should_explode) {
          bombs.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
          explosions_spawned++;
        }

        bomb.x = x;
        bomb.y = y;
      }

      for (const [ id, interceptor ] of interceptors) {
        const x1 = interceptor.start_x;
        const y1 = 1 - ground_height;
        const x2 = interceptor.target_x;
        const y2 = interceptor.target_y;
        const x_diff = x1 - x2;
        const y_diff = y1 - y2;
        const length = Math.sqrt(y_diff * y_diff + x_diff * x_diff);
        const t = (now - interceptor.spawn_time) / length * interceptor_velocity;
        const x = lerp(x1, x2, t);
        const y = lerp(y1, y2, t);

        if (t > 1) {
          interceptors.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
          explosions_spawned++;
        }

        interceptor.x = x;
        interceptor.y = y;
      }

      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive) {
          const x = interceptor_slot.x;
          const y = 1 - ground_height;
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y, color: random_explosion_color() });
              explosions_spawned++;
              interceptor_slot.alive = false;
              interceptor_slot.destroyed_at = now;
              break;
            }
          }
        }
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = 'gray';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.translate(x_offset, y_offset);

      ctx.fillStyle = color__background;
      ctx.fillRect(0, 0, size, size);

      ctx.fillStyle = color__ground;
      ctx.fillRect(0, (1 - ground_height) * size, size, ground_height * size);

      ctx.lineWidth = 2;

      ctx.strokeStyle = color__missile;
      ctx.beginPath();
      for (const missile of missiles.values()) {
        ctx.moveTo(missile.start * size, 0);
        ctx.lineTo(missile.x * size, missile.y * size);
      }
      ctx.stroke();

      ctx.fillStyle = color__bomb;
      ctx.beginPath();
      for (const bomb of bombs.values()) {
        ctx.fillRect((bomb.x - bomb_size / 2) * size, (bomb.y - bomb_size / 2) * size, bomb_size * size, bomb_size * size);
      }
      ctx.stroke();

      ctx.fillStyle = color__interceptor;
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        ctx.arc(interceptor.x * size, interceptor.y * size, marker_radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = color__interceptor_slot;
      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive || now - interceptor_slot.destroyed_at < explosion_duration / 2) {
          ctx.beginPath();
          ctx.fillRect(interceptor_slot.x * size - marker_radius * size, (1 - ground_height) * size, marker_radius * size * 2, ground_height * size);
          ctx.fill();
        }
      }

      ctx.fillStyle = color__interceptor;
      for (const interceptor_slot of interceptor_slots) {
        if (interceptor_slot.alive) {
          for (let i = 0; i < interceptor_slot.bullet_fire_times.length; i++) {
            let adjusted_i = (interceptor_slot.next_bullet_index + i) % interceptor_slot.bullet_fire_times.length;
            let bullet_fire_time = interceptor_slot.bullet_fire_times[adjusted_i];
            let extra_offset = (i + interceptor_slot.next_bullet_index - interceptor_slot_bullet_index_snapshot(interceptor_slot, now)) * marker_radius * 2;
            let offset = Math.max(0, lerp(ground_height, 0, (now - bullet_fire_time) / interceptor_slot_reload_period)) + extra_offset;
            ctx.beginPath();
            ctx.arc(interceptor_slot.x * size, ((1 - ground_height) + offset) * size, marker_radius * size, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      }

      ctx.globalAlpha = 0.5;
      for (const explosion of explosions.values()) {
        ctx.fillStyle = explosion.color;
        const x = explosion.x * size;
        const y = explosion.y * size;
        ctx.beginPath();
        ctx.arc(x, y, explosion.radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.strokeStyle = color__interceptor_target;
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        const x = interceptor.target_x * size;
        const y = interceptor.target_y * size;
        const diff = size * 0.01;
        ctx.moveTo(x - diff, y - diff);
        ctx.lineTo(x + diff, y + diff);
        ctx.moveTo(x + diff, y - diff);
        ctx.lineTo(x - diff, y + diff);
        ctx.stroke();
      }

      ctx.fillStyle = color__text;
      ctx.font = `bold 15px monospace`;
      ctx.globalAlpha = 0.5;
      ctx.fillText(` wave: ${current_wave + 1}`, 5, 15);
      ctx.fillText(`score: ${score}`, 5, 30);
      ctx.globalAlpha = 1;

      if (current_wave_finished || game_lost) {
        const fired = interceptors_spawned - interceptors_spawned_at_wave_start;
        const level_score = fired * -interceptor_cost +
          current_wave_missiles_intercepted * missile_intercept_gain +
          current_wave_bombs_intercepted * bomb_intercept_gain +
          current_wave_interceptor_slots_alive_at_end * interceptor_slot_alive_at_wave_end_gain;
        let line1 = `wave ${current_wave + 1} finished`;
        if (game_lost) {
          line1 = `wave ${current_wave + 1} failed. game over!`;
        } else if (current_wave === waves.length - 1) {
          line1 += '. game over!';
        }
        let line3 = `fired:    ${fired} x -${interceptor_cost} each`;
        let line4 = `missiles: ${current_wave_missiles_intercepted} x ${missile_intercept_gain} each`;
        let line5 = `bombs:    ${current_wave_bombs_intercepted} x ${bomb_intercept_gain} each`;
        let line6 = `towers:   ${current_wave_interceptor_slots_alive_at_end} x ${interceptor_slot_alive_at_wave_end_gain} each`;
        let line8 = `level:    ${level_score}`;
        let line9 = `total:    ${score}`;
        let content_lines = [ line1, line3, line4, line5, line6, line8, line9 ];

        let width = size;
        let characters = 0;
        let font_size_px = 30;
        for (; width > 0.8 * size; font_size_px--) {
          ctx.font = `${font_size_px}px monospace`;
          width = 0;
          for (const line of content_lines) {
            const candidate_width = ctx.measureText(line).width;
            if (candidate_width > width) {
              width = candidate_width;
              characters = line.length;
            }
          }
        }

        const lines = [
          line1,
          '='.repeat(characters),
          line3,
          line4,
          line5,
          line6,
          '-'.repeat(characters),
          line8,
          line9
        ];

        const line_height = font_size_px * 1.2;
        const x = 0.5 * size - width / 2;
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, 0.5 * size + i * line_height - (lines.length * (line_height / 2)));
        }

        if (current_wave < waves.length - 1) {
          const loading_bar_width = Math.max(0, (level_summary_duration - (now - current_wave_finished_at)) / level_summary_duration) * width;
          ctx.fillRect(x, 0.5 * size + lines.length * (line_height / 2) - line_height / 2, loading_bar_width, line_height);
        }
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
