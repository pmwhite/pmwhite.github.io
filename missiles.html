<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 100%;
    }
    #game {
      display: block;
      background: #fff;
      width: 100%;
      height: 100dvh;
      margin: auto;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1000" height="500"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let size = 500;
    let x_offset = 0;
    let y_offset = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      size = Math.min(canvas.width, canvas.height);
      x_offset = (canvas.width - size) / 2;
      y_offset = (canvas.height - size) / 2;
    }

    window.addEventListener('resize', resize);
    resize();

    let missiles = new Map();
    let missile_spawn_period = 3000;
    let missile_velocity = 1 / 20000;
    let missiles_spawned = 0;

    let interceptors = new Map();
    let interceptor_slot_reload_period = 2000;
    let interceptor_velocity = 6 / 20000;
    let interceptors_spawned = 0;
    let interceptor_slot_count = 6;
    let interceptor_spawn_period = interceptor_slot_reload_period / interceptor_slot_count;
    let interceptor_slots = [];
    for (let i = 0; i < interceptor_slot_count; i++) {
      interceptor_slots.push({ x: (i + 0.5) / (interceptor_slot_count), last_used_at: -interceptor_slot_reload_period });
    }

    let explosions = new Map();
    let explosions_spawned = 0;
    let explosion_radius = 30 / 1000;
    let explosion_duration = 5000;

    let marker_radius = 5 / 1000;
    let ground_height = 0.03;

    const game_start_time = performance.now();

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    let mouse_down_time = 0;
    let mouse_is_down = false;
    let mouse_x = 0;
    let mouse_y = 0;

    let waves = [
      { start_at: 2000, count: 10, period: 1000 },
      { start_at: 20000, count: 15, period: 500 },
    ];

    document.addEventListener('contextmenu', event => event.preventDefault());

    canvas.addEventListener('pointerdown', ev => {
      mouse_is_down = true;
      mouse_down_time = performance.now();
      mouse_x = (ev.clientX - x_offset) / size;
      mouse_y = (ev.clientY - y_offset) / size;
      interceptors_spawned_during_strafe = 0;
      ev.preventDefault();
    });

    canvas.addEventListener('pointermove', ev => {
      mouse_x = (ev.clientX - x_offset) / size;
      mouse_y = (ev.clientY - y_offset) / size;
      ev.preventDefault();
    });

    canvas.addEventListener('pointerup', ev => {
      mouse_is_down = false;
      ev.preventDefault();
    });

    function frame() {
      const now = performance.now();
      const missile_spawn_t = now - game_start_time;
      let expected_missiles = 0;
      for (const wave of waves) {
        expected_missiles += Math.max(0, Math.min(wave.count, Math.ceil((missile_spawn_t - wave.start_at) / wave.period)));
      };
      const new_missiles_to_spawn = expected_missiles - missiles_spawned;
      for (let i = 0; i < new_missiles_to_spawn; i++) {
        missiles.set(missiles_spawned, { spawn_time: now, start: Math.random(), end: Math.random() });
        missiles_spawned++;
      }

      if (mouse_is_down) {
        const new_interceptors_to_spawn = Math.floor((now - mouse_down_time) / interceptor_spawn_period) - interceptors_spawned_during_strafe + 1;
        for (let i = 0; i < new_interceptors_to_spawn; i++) {
          let closest_interceptor_slot = interceptor_slots[0];
          for (let slot_index = 0; slot_index < interceptor_slot_count; slot_index++) {
            let next_interceptor_slot = interceptor_slots[slot_index];
            let slot_x = (slot_index + 0.5) / interceptor_slot_count;
            if (now - next_interceptor_slot.last_used_at > interceptor_slot_reload_period
              && (now - closest_interceptor_slot.last_used_at <= interceptor_slot_reload_period
                 || Math.abs(next_interceptor_slot.x - mouse_x) < Math.abs(closest_interceptor_slot.x - mouse_x))) {
              closest_interceptor_slot = next_interceptor_slot;
            }
          }
          if (now - closest_interceptor_slot.last_used_at > interceptor_slot_reload_period) {
            closest_interceptor_slot.last_used_at = now;
            interceptors.set(interceptors_spawned, { spawn_time: now, target_x: mouse_x, target_y: mouse_y, start_x: closest_interceptor_slot.x });
            interceptors_spawned++;
            interceptors_spawned_during_strafe++;
          }
        }
      }

      for (const [ id, explosion ] of explosions) {
        const t = (now - explosion.spawn_time) / explosion_duration + 0.1;
        const radius = Math.sin(t * Math.PI) * explosion_radius;

        if (t > 1) {
          explosions.delete(id);
        }

        explosion.radius = radius;
      }


      for (const [ id, missile ] of missiles) {
        const end_start_diff = missile.end - missile.start;
        const length = Math.sqrt(1 + end_start_diff * end_start_diff);
        const t = (now - missile.spawn_time) / length * missile_velocity;
        const x = lerp(missile.start, missile.end, t);
        const y = lerp(0, 1 - ground_height, t);

        let should_explode = t > 1;
        if (!should_explode) {
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x - x;
            const y_diff = explosion.y - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              should_explode = true;
              break;
            }
          }
        }

        if (should_explode) {
          missiles.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y });
          explosions_spawned++;
        }

        missile.x = x;
        missile.y = y;
      }

      for (const [ id, interceptor ] of interceptors) {
        const x1 = interceptor.start_x;
        const y1 = 1 - ground_height;
        const x2 = interceptor.target_x;
        const y2 = interceptor.target_y;
        const x_diff = x1 - x2;
        const y_diff = y1 - y2;
        const length = Math.sqrt(y_diff * y_diff + x_diff * x_diff);
        const t = (now - interceptor.spawn_time) / length * interceptor_velocity;
        const x = lerp(x1, x2, t);
        const y = lerp(y1, y2, t);

        if (t > 1) {
          interceptors.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x, y: y });
          explosions_spawned++;
        }

        interceptor.x = x;
        interceptor.y = y;
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = 'gray';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.translate(x_offset, y_offset);

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, size, size);

      ctx.lineWidth = 2;

      ctx.strokeStyle = 'yellow';
      ctx.beginPath();
      for (const missile of missiles.values()) {
        ctx.moveTo(missile.start * size, 0);
        ctx.lineTo(missile.x * size, missile.y * size);
      }
      ctx.stroke();

      ctx.fillStyle = 'blue';
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        ctx.arc(interceptor.x * size, interceptor.y * size, marker_radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = 'gray';
      for (const interceptor_slot of interceptor_slots) {
        ctx.beginPath();
        ctx.fillRect(interceptor_slot.x * size - marker_radius * size, (1 - ground_height) * size, marker_radius * size * 2, ground_height * size);
        ctx.fill();
      }

      ctx.fillStyle = 'blue';
      for (const interceptor_slot of interceptor_slots) {
        let offset = Math.max(0, (interceptor_slot_reload_period - now + interceptor_slot.last_used_at) / interceptor_slot_reload_period * ground_height);
        ctx.beginPath();
        ctx.arc(interceptor_slot.x * size, ((1 - ground_height) + offset) * size, marker_radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = 'white';
      for (const explosion of explosions.values()) {
        const x = explosion.x * size;
        const y = explosion.y * size;
        ctx.beginPath();
        ctx.arc(x, y, explosion.radius * size, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = 'red';
      for (const interceptor of interceptors.values()) {
        ctx.beginPath();
        ctx.arc(interceptor.target_x * size, interceptor.target_y * size, 5, 0, 2 * Math.PI);
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
