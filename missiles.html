<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 100%;
    }
    #game {
      display: block;
      background: #fff;
      width: 100%;
      height: 100dvh;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1000" height="500"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    let missiles = new Map();
    let missile_spawn_period = 500;
    let missile_velocity = 1 / 10000;
    let missiles_spawned = 0;

    let interceptors = new Map();
    let interceptor_velocity = 6 / 10000;
    let interceptors_spawned = 0;

    let explosions = new Map();
    let explosions_spawned = 0;
    let explosion_radius = 60 / 1000;
    let explosion_duration = 5000;

    const game_start_time = performance.now();

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    canvas.addEventListener('click', ev => {
      const now = performance.now();
      const x = ev.clientX / canvas.width;
      const y = ev.clientY / canvas.height;
      interceptors.set(interceptors_spawned, { spawn_time: now, target_x: x, target_y: y });
      interceptors_spawned++;
    });

    function frame() {
      const now = performance.now();
      const new_missiles_to_spawn = Math.floor((now - game_start_time) / missile_spawn_period) - missiles_spawned;
      for (let i = 0; i < new_missiles_to_spawn; i++) {
        missiles.set(missiles_spawned, { spawn_time: now, start: Math.random(), end: Math.random() });
        missiles_spawned++;
      }

      for (const [ id, explosion ] of explosions) {
        const t = (now - explosion.spawn_time) / explosion_duration + 0.1;
        const radius = Math.sin(t * Math.PI) * explosion_radius * canvas.height;

        if (t > 1) {
          explosions.delete(id);
        }

        explosion.radius = radius;
      }


      for (const [ id, missile ] of missiles) {
        const x1 = missile.start * canvas.width;
        const x2 = missile.end * canvas.width;
        const length = Math.sqrt(canvas.height * canvas.height + (x2 - x1) * (x2 - x1));
        const t = (now - missile.spawn_time) / length * canvas.height * missile_velocity;
        const x = lerp(x1, x2, t);
        const y = lerp(0, canvas.height, t);

        let should_explode = t > 1;
        if (!should_explode) {
          for (const explosion of explosions.values()) {
            const x_diff = explosion.x * canvas.width - x;
            const y_diff = explosion.y * canvas.height - y;
            const dist = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
            if (dist < explosion.radius) {
              should_explode = true;
              break;
            }
          }
        }

        if (should_explode) {
          missiles.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x / canvas.width, y: y / canvas.height });
          explosions_spawned++;
        }

        missile.x1 = x1;
        missile.x = x;
        missile.y = y;
      }

      for (const [ id, interceptor ] of interceptors) {
        const x1 = canvas.width / 2;
        const x2 = interceptor.target_x * canvas.width;
        const y1 = canvas.height;
        const y2 = interceptor.target_y * canvas.height;
        const length = Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
        const t = (now - interceptor.spawn_time) / length * canvas.height * interceptor_velocity;
        const x = lerp(x1, x2, t);
        const y = lerp(y1, y2, t);

        if (t > 1) {
          interceptors.delete(id);
          explosions.set(explosions_spawned, { spawn_time: now, x: x / canvas.width, y: y / canvas.height });
          explosions_spawned++;
        }

        interceptor.x1 = x1;
        interceptor.y1 = y1;
        interceptor.x = x;
        interceptor.y = y;
      }

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.lineWidth = 2;

      ctx.strokeStyle = 'yellow';
      ctx.beginPath();
      for (const missile of missiles.values()) {
        ctx.moveTo(missile.x1, 0);
        ctx.lineTo(missile.x, missile.y);
      }
      ctx.stroke();

      ctx.strokeStyle = 'blue';
      ctx.beginPath();
      for (const interceptor of interceptors.values()) {
        ctx.moveTo(interceptor.x1, interceptor.y1);
        ctx.lineTo(interceptor.x, interceptor.y);
      }
      ctx.stroke();

      ctx.fillStyle = 'white';
      for (const explosion of explosions.values()) {
        const x = explosion.x * canvas.width;
        const y = explosion.y * canvas.height;
        ctx.beginPath();
        ctx.arc(x, y, explosion.radius, 0, 2 * Math.PI);
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
