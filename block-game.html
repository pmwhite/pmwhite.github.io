<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 100%;
    }
    #game {
      display: block;
      background: #fff;
      width: 100%;
      height: 100dvh;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1200" height="540"></canvas>

  <script src="level.js"></script>
  <script>
    let grid_square_size = 60;
    const grid_height = 9;
    const grid_width = 20;
    const step_duration = 200;
    const canvas = document.getElementById('game');

    canvas.addEventListener('dblclick', () => {
    });

    const ctx = canvas.getContext('2d');

    let player = { column: 0, row: 0 };
    let blocks = new Map();
    let checkpoint_columns = new Map();
    let history = [];
    const cursor = { column: 0, row: 0 };
    let current_history_transition_started_at = 0;
    let mode = 'play';

    let viewport = { state: 'idle' };
    let viewport_left = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const grid_square_size_from_width = Math.floor(window.innerWidth / grid_width);
      const grid_square_size_from_height = Math.floor(window.innerHeight / grid_height);
      grid_square_size = Math.min(grid_square_size_from_width, grid_square_size_from_height);
      viewport_left = get_viewport_left_target(player.column, player.column, 0);
      viewport = { state: 'idle' };
    }

    window.addEventListener('resize', resize);
    resize();


    let handle;

    async function save_edit_data() {
      let contents = "";
      contents += "let edit_data = {\n";
      contents += "  blocks: new Map([\n";
      for (const [key, value] of edit_data.blocks) {
        contents += `    [ ${key}, { column: ${value.column}, row: ${value.row}`;
        if (value.shape) {
          contents += `, shape: ${value.shape}`;
        }
        contents += ` } ],\n`;
      }
      contents += "  ]),\n";
      contents += "  player: { column: 0, row: 0 },\n";
      contents += "  checkpoint_columns: new Map([\n";
      for (const [ column, title ] of edit_data.checkpoint_columns) {
        contents += `    [ ${column}, "${title}" ],\n`;
      }
      contents += "  ])\n";
      contents += "};\n";

      if (!handle) {
        handle = await window.showSaveFilePicker({ suggestedName: "level.js" });
      }
      const writable = await handle.createWritable();
      await writable.write(contents);
      await writable.close();
    }

    function add_block(column, row) {
      let i = 0;
      while (blocks.get(i)) {
        i++;
      }
      blocks.set(i, { column: column, row: row });
    }

    function add_block_with_shape(column, row, shape) {
      let i = 0;
      while (blocks.get(i)) {
        i++;
      }
      blocks.set(i, { column: column, row: row, shape: shape });
    }

    function add_current_state_to_history() {
      const now = performance.now();
      if (history.length === 1) {
        current_history_transition_started_at = now;
      }
      history.push(structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns }));
    }

    function reset_to_edit_data() {
      const data = structuredClone(edit_data);
      player.column = find_prev_or_same_checkpoint_column(player.column);
      blocks = data.blocks;
      checkpoint_columns = data.checkpoint_columns;
    }

    function update_edit_data() {
      edit_data = structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns });
    }

    reset_to_edit_data();
    add_current_state_to_history();

    function in_bounds(column, row) {
      return column >= 0 && row >= 0 && row < grid_height;
    }

    function can_move_block(block, column_diff, row_diff) {
      const target_column = block.column + column_diff;
      const target_row = block.row + row_diff;
      let can_move = in_bounds(target_column, target_row);
      for (const other of blocks.values()) {
        if (other.column === target_column && other.row === target_row) {
          if (block.shape) {
            can_move = other.shape === block.shape;
          } else {
            can_move = false;
          }
          break;
        }
      }
      for (const checkpoint_column of checkpoint_columns.keys()) {
        if (checkpoint_column === target_column) {
          can_move = false;
          break;
        }
      }
      return can_move;
    }

    function move_player(is_repeat, column_diff, row_diff) {
      // Since there is plenty of opportunity to make unfixable mistakes, we
      // want each key press to be intentional. Toward that end, if the key is
      // being held down, we only do one move at a time (which allows the user to
      // move smoothly by holding down a key). But if the key is not being
      // held, then it was probably hit repeatedly on purpose, which means we can
      // allow going ahead by more than one move (which allows the user to not
      // have to wait for the animation to finish before pressing the key for
      // the next move).
      if (history.length < 5 && !is_repeat || history.length < 2) {
        const target_column = player.column + column_diff;
        const target_row = player.row + row_diff;
        const prev_checkpoint_column = find_prev_or_same_checkpoint_column(player.column);
        const next_checkpoint_column = find_next_checkpoint_column(player.column);
        if (in_bounds(target_column, target_row)) {
          let can_move_to_space = true;
          for (const block of blocks.values()) {
            if (block.row === target_row && block.column === target_column) {
              can_move_to_space = false;
              if (can_move_block(block, column_diff, row_diff)) {
                let can_move_blocks = true;
                let blocks_to_move = [];
                if (block.shape) {
                  for (const block_with_shape of blocks.values()) {
                    if (block_with_shape.column > prev_checkpoint_column && block_with_shape.column < next_checkpoint_column && block_with_shape.shape === block.shape) {
                      if (!can_move_block(block_with_shape, column_diff, row_diff)) {
                        can_move_blocks = false;
                        break;
                      }
                      blocks_to_move.push(block_with_shape);
                    }
                  }
                } else {
                  blocks_to_move.push(block);
                }
                if (can_move_blocks) {
                  can_move_to_space = true;
                  for (const block_to_move of blocks_to_move) {
                    block_to_move.column += column_diff;
                    block_to_move.row += row_diff;
                  }
                }
              }
              break;
            }
          }
          if (can_move_to_space) {
            player.column = target_column;
            player.row = target_row;
          }
        }
        add_current_state_to_history();
      }
    }

    function move_cursor(column_diff, row_diff) {
      const target_column = cursor.column + column_diff;
      const target_row = cursor.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        cursor.column = target_column;
        cursor.row = target_row;
      }
    }

    function find_prev_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns.keys()) {
        if (checkpoint_column < column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_prev_or_same_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns.keys()) {
        if (checkpoint_column <= column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_next_checkpoint_column(column) {
      let next_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns.keys()) {
        if (checkpoint_column > next_checkpoint_column) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      for (const checkpoint_column of checkpoint_columns.keys()) {
        if ((checkpoint_column > column && checkpoint_column < next_checkpoint_column) || next_checkpoint_column === 0) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      return next_checkpoint_column;
    }

    function toggle_shape_block(shape) {
      let found_block = false;
      for (const [key, block] of blocks) {
        if (block.column === cursor.column && block.row === cursor.row) {
          found_block = true;
          blocks.delete(key);
          break;
        }
      }
      if (!found_block) {
        add_block_with_shape(cursor.column, cursor.row, shape);
      }
    }

    function go_to_prev_level() {
      history = [];
      add_current_state_to_history();
      const prev_checkpoint_column = find_prev_checkpoint_column(player.column);
      reset_to_edit_data();
      player.column = prev_checkpoint_column;
      add_current_state_to_history();
    }

    function go_to_next_level() {
      history = [];
      add_current_state_to_history();
      const next_checkpoint_column = find_next_checkpoint_column(player.column);
      reset_to_edit_data();
      player.column = next_checkpoint_column;
      add_current_state_to_history();
    }

    function get_top_margin() {
      return Math.floor((window.innerHeight - grid_height * grid_square_size) / 2);
    }

    function get_left_margin() {
      return Math.floor((window.innerWidth - grid_width * grid_square_size) / 2);
    }

    let control_mode = 'keyboard';
    let touch_start_x = 0;
    let touch_start_time = 0;

    canvas.addEventListener('touchstart', ev => {
      ev.preventDefault(); // Prevent default touch behavior like scrolling
      const touch = ev.touches[0];
      touch_start_x = touch.clientX;
      touch_start_time = performance.now();
    });

    canvas.addEventListener('touchend', ev => {
      ev.preventDefault();
      const touch = ev.changedTouches[0];

      switch (control_mode) {
        case 'pointer':
          if (Math.abs(touch.clientX - touch_start_x) > 50 && performance.now() - touch_start_time < 300) {
            if (touch.clientX > touch_start_x) {
              go_to_next_level();
            } else {
              go_to_prev_level();
            }
          } else {
            const x = touch.clientX - get_left_margin();
            const y = touch.clientY - get_top_margin();
            const diag1_y = x * grid_height / grid_width;
            const diag2_y = grid_height * grid_square_size - diag1_y;
            if (y > diag1_y) {
              if (y > diag2_y) {
                move_player(false, 0, 1);
              } else {
                move_player(false, -1, 0);
              }
            } else {
              if (y > diag2_y) {
                move_player(false, 1, 0);
              } else {
                move_player(false, 0, -1);
              }
            }
          }
          break;
        case 'keyboard':
          control_mode = 'pointer';
          break;
      }
    });

    document.addEventListener('keydown', async ev => {
      switch (mode) {
        case 'play':
          switch (control_mode) {
            case 'pointer':
              control_mode = 'keyboard';
              break;
            case 'keyboard':
              if (ev.shiftKey) {
                switch (ev.key) {
                  case 'ArrowLeft':
                    go_to_prev_level();
                    break;
                  case 'ArrowRight':
                    go_to_next_level();
                    break;
                }
              } else {
                switch (ev.key) {
                  case 'ArrowLeft':
                    move_player(ev.repeat, -1, 0);
                    break;
                  case 'ArrowRight':
                    move_player(ev.repeat, 1, 0);
                    break;
                  case 'ArrowUp':
                    move_player(ev.repeat, 0, -1);
                    break;
                  case 'ArrowDown':
                    move_player(ev.repeat, 0, 1);
                    break;
                  case 'm':
                    reset_to_edit_data();
                    mode = 'edit';
                    break;
                }
              }
              break;
          }


          break;
        case 'edit':
          if (ev.shiftKey) {
            switch (ev.key) {
              case 'ArrowLeft':
                cursor.column = find_prev_checkpoint_column(cursor.column);
                break;
              case 'ArrowRight':
                cursor.column = find_next_checkpoint_column(cursor.column);
                break;
            }
          } else {
            switch (ev.key) {
              case 'ArrowLeft':
                move_cursor(-1, 0);
                break;
              case 'ArrowRight':
                move_cursor(1, 0);
                break;
              case 'ArrowUp':
                move_cursor(0, -1);
                break;
              case 'ArrowDown':
                move_cursor(0, 1);
                break;
              case 'm':
                reset_to_edit_data();
                let history = [];
                add_current_state_to_history();
                mode = 'play';
                break;
              case 'b':
                let found_block = false;
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column && block.row === cursor.row) {
                    found_block = true;
                    blocks.delete(key);
                    break;
                  }
                }
                if (!found_block) {
                  add_block(cursor.column, cursor.row);
                }
                break;
              case '3':
                toggle_shape_block(3);
                break;
              case '4':
                toggle_shape_block(4);
                break;
              case '5':
                toggle_shape_block(5);
                break;
              case '6':
                toggle_shape_block(6);
                break;
              case '7':
                toggle_shape_block(15);
                break;
              case 'c':
                if (checkpoint_columns.has(cursor.column)) {
                  checkpoint_columns.delete(cursor.column);
                } else {
                  let can_add_checkpoint_column = true;
                  for (const block of blocks.values()) {
                    if (cursor.column === block.column) {
                      can_add_checkpoint_column = false;
                    }
                  }
                  if (can_add_checkpoint_column) {
                    checkpoint_columns.add(cursor.column);
                  }
                }
                break;
              case 'i':
                for (const block of blocks.values()) {
                  if (block.column >= cursor.column) {
                    block.column += 1;
                  }
                }
                const new_checkpoint_columns = new Set();
                for (const [ column, title ] of checkpoint_columns) {
                  if (column >= cursor.column) {
                    new_checkpoint_columns.set(column + 1, title);
                  } else {
                    new_checkpoint_columns.set(column, title);
                  }
                }
                checkpoint_columns = new_checkpoint_columns;
                break;
              case 'd':
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column) {
                    blocks.delete(key);
                  } else if (block.column > cursor.column) {
                    block.column -= 1;
                  }
                }
                const new_checkpoint_columns2 = new Set();
                for (const [ column, title ] of checkpoint_columns) {
                  if (column > cursor.column) {
                    new_checkpoint_columns2.set(column - 1, title);
                  } else if (column !== cursor.column) {
                    new_checkpoint_columns2.add(column, title);
                  }
                }
                checkpoint_columns = new_checkpoint_columns2;
                break;
              case 's':
                await save_edit_data();
                break;
            }
          }
          update_edit_data();
          break;
      }
    });

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function get_viewport_left_target(from_column, to_column, lerp_remainder) {
      const viewport_left_min = grid_width / 2 * grid_square_size;
      const player_x = Math.floor(grid_square_size * lerp(from_column, to_column, lerp_remainder));
      const viewport_left_start = Math.floor(grid_square_size * lerp(find_prev_or_same_checkpoint_column(from_column), find_prev_or_same_checkpoint_column(to_column), lerp_remainder));
      const viewport_left_end = Math.floor(grid_square_size * lerp(find_next_checkpoint_column(from_column), find_next_checkpoint_column(to_column), lerp_remainder)) - (grid_width - 1) * grid_square_size;
      return Math.max(viewport_left_start, Math.min(viewport_left_end, player_x - viewport_left_min));
    }

    function fill_shape(column, row, shape) {
      const shape_radius = grid_square_size / 3;
      const cx = grid_square_size * column + grid_square_size / 2;
      const cy = grid_square_size * row + grid_square_size / 2;
      ctx.beginPath();
      for (let i = 0; i < shape; i += 1) {
        const angle = 2 * Math.PI / shape * i - Math.PI / 2;
        const x = cx + Math.cos(angle) * shape_radius;
        const y = cy + Math.sin(angle) * shape_radius;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.fill();
    }

    function render_play() {
      let now = performance.now();
      const delta = now - current_history_transition_started_at;
      const lerp_t = delta / step_duration;
      const lerp_floor = Math.floor(lerp_t);
      const lerp_remainder = lerp_t - lerp_floor;
      const from = history[Math.min(history.length - 1, lerp_floor)];
      const to = history[Math.min(history.length - 1, lerp_floor + 1)]; 
      const viewport_left_target = get_viewport_left_target(from.player.column, to.player.column, lerp_remainder);

      const current_checkpoint_column = find_prev_or_same_checkpoint_column(from.player.column);
      const new_checkpoint_column = find_prev_or_same_checkpoint_column(to.player.column);

      switch (viewport.state) {
        case 'idle':
          let speed = 0.2;
          if (current_checkpoint_column !== new_checkpoint_column) {
            speed = 2;
          }
          if (viewport_left_target < viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: -1 * speed, started_at: now };
          } else if (viewport_left_target > viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: speed, started_at: now };
          }
          break;
        case 'tracking':
          const new_viewport_left = Math.floor(lerp(viewport.base, viewport.base + viewport.vector, now - viewport.started_at));
          if ((viewport.vector > 0 && new_viewport_left > viewport_left_target) || (viewport.vector < 0 && new_viewport_left < viewport_left_target)) {
            if ((viewport.vector > 0 && viewport_left < viewport_left_target) || (viewport.vector < 0 && viewport_left > viewport_left_target)) {
              viewport_left = viewport_left_target;
            }
            viewport = { state: 'idle' };
          } else {
            viewport_left = new_viewport_left;
          }
          break;
      }

      const left_margin = get_left_margin();
      const top_margin = get_top_margin();
      ctx.translate(left_margin - viewport_left, top_margin);

      ctx.fillStyle = '#4d7c0f';
      for (const column of checkpoint_columns.keys()) {
        ctx.fillRect(grid_square_size * column, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(
        Math.floor(grid_square_size * lerp(from.player.column, to.player.column, lerp_remainder)),
        grid_square_size * lerp(from.player.row, to.player.row, lerp_remainder),
        grid_square_size, grid_square_size);

      ctx.fillStyle = '#a8a29e';
      for (const [key, to_block] of to.blocks) {
        const from_block = from.blocks.get(key);
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        ctx.fillRect(grid_square_size * column, grid_square_size * row, grid_square_size, grid_square_size);
      }

      ctx.fillStyle = '#fcd34d';
      for (const [key, to_block] of to.blocks) {
        const from_block = from.blocks.get(key);
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        fill_shape(column, row, to_block.shape);
      }

      if (history.length > 1 && lerp_t > 1) {
        history.shift(Math.max(0, Math.min(history.length - 1, lerp_floor)));
        current_history_transition_started_at = now - lerp_remainder;
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.translate(left_margin, top_margin);

      ctx.font = `bold 50px sans-serif`;
      ctx.fillStyle = '#a5b4fc';

      const from_title = checkpoint_columns.get(current_checkpoint_column);
      const to_title = checkpoint_columns.get(new_checkpoint_column);
      const title_x = grid_square_size + grid_square_size / 2;
      const title_y = grid_square_size * (grid_height - 1);
      if (from_title === to_title) {
        ctx.fillText(from_title, title_x, title_y);
      } else {
        ctx.globalAlpha = lerp(1, 0, lerp_remainder);
        ctx.fillText(from_title, title_x, title_y);
        ctx.globalAlpha = lerp(0, 1, lerp_remainder);
        ctx.fillText(to_title, title_x, title_y);
      }
      ctx.globalAlpha = 1;

      switch (control_mode) {
        case 'pointer':
          ctx.lineWidth = 5;

          const gradient1 = ctx.createLinearGradient(0, 0, grid_square_size * grid_width, grid_square_size * grid_height);
          gradient1.addColorStop(0.3, '#ffffff00');
          gradient1.addColorStop(0.5, '#ffffff77');
          gradient1.addColorStop(0.7, '#ffffff00');
          ctx.strokeStyle = gradient1;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(grid_square_size * grid_width, grid_square_size * grid_height);
          ctx.stroke();

          const gradient2 = ctx.createLinearGradient(grid_square_size * grid_width, 0, 0, grid_square_size * grid_height);
          gradient2.addColorStop(0.3, '#ffffff00');
          gradient2.addColorStop(0.5, '#ffffff77');
          gradient2.addColorStop(0.7, '#ffffff00');
          ctx.strokeStyle = gradient2;
          ctx.beginPath();
          ctx.moveTo(grid_square_size * grid_width, 0);
          ctx.lineTo(0, grid_square_size * grid_height);
          ctx.stroke();

          break;
        case 'keyboard':
          break;
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, left_margin, window.innerHeight);
      ctx.fillRect(0, 0, window.innerWidth, top_margin);
      const grid_right = left_margin + grid_square_size * grid_width;
      ctx.fillRect(grid_right, top_margin, window.innerWidth - grid_right, window.innerHeight);
      const grid_bottom = top_margin + grid_square_size * grid_height;
      ctx.fillRect(left_margin, grid_bottom, window.innerWidth, window.innerHeight - grid_bottom);
    }

    function render_edit() {
      const viewport_left_min = grid_width / 2 * grid_square_size;
      const translate_x = Math.max(0, Math.floor(cursor.column * grid_square_size - viewport_left_min));
      const left_margin = Math.floor((window.innerWidth - grid_width * grid_square_size) / 2);
      const top_margin = Math.floor((window.innerHeight - grid_height * grid_square_size) / 2);
      ctx.translate(-translate_x, 0);

      ctx.fillStyle = '#4d7c0f';
      for (const column of checkpoint_columns.keys()) {
        ctx.fillRect(grid_square_size * column, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#a8a29e';
      for (const block of blocks.values()) {
        ctx.fillRect(grid_square_size * block.column, grid_square_size * block.row, grid_square_size, grid_square_size);
      }

      ctx.fillStyle = '#fcd34d';
      for (const block of blocks.values()) {
        if (block.shape) {
          fill_shape(block.column, block.row, block.shape);
        }
      }

      ctx.strokeStyle = '#059669';
      ctx.lineWidth = 2;
      ctx.strokeRect(grid_square_size * cursor.column, grid_square_size * cursor.row, grid_square_size, grid_square_size);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = '20px sans-serif';
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(`Editing Level`, 10, 30);
      ctx.fillText(`Cursor: column ${cursor.column}, row ${cursor.row}`, 10, 60);
    }

    function render() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#44403c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      switch (mode) {
        case 'play':
          render_play();
          break;
        case 'edit':
          render_edit();
          break;
      }

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

  </script>
</body>
</html>
