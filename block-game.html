<!DOCTYPE html>
<!--
todo list:
- When the player reaches a checkpoint column, the world should auto-reset. We
currently reset whenever they explicitly switch from one level to the next, but
there is the awkward case in which they are already at the beginning of the
level and want to reset it. We could either have a key to reset it explicitly,
or the user could switch forward and than backward again to reset it. Both of
these seem silly to me, and I kinda like making it a principle of the game that
the state of the world is ephemeral. That is, you shouldn't hold on tightly to
how things are, but rather focus on how to solve the original puzzle. You
shouldn't have to worry about long-lasting state. Each puzzle is small and
self-contained with respect to state.

- Add ability to save level edits repeatedly.

-->
<html>
<head>
  <meta charset="utf-8">
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: 0px auto;
    }
    #game {
      display: block;
      background: #fff;
      width: 1200px;
      height: 480px;
      margin: 0px auto;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1200" height="480"></canvas>
  <script src="level.js"></script>
  <script>
    const grid_square_size = 60;
    const grid_height = 8;
    const grid_width = 20;
    const step_duration = 200;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let player = { column: 0, row: 0 };
    let blocks = new Map();
    let checkpoint_columns = new Set();
    let history = [];
    const cursor = { column: 0, row: 0 };
    let current_history_transition_started_at = 0;
    let mode = 'play';

    let viewport = { state: 'idle' };
    const viewport_left_min = grid_width / 2 * grid_square_size;
    let viewport_left = 0;
    let handle;

    async function save_edit_data() {
      let contents = "";
      contents += "let edit_data = {\n";
      contents += "  blocks: new Map([\n";
      for (const [key, value] of edit_data.blocks) {
        contents += `    [ ${key}, { column: ${value.column}, row: ${value.row} } ],\n`;
      }
      contents += "  ]),\n";
      contents += "  player: { column: 0, row: 0 },\n";
      contents += "  checkpoint_columns: new Set([\n";
      for (const checkpoint_column of edit_data.checkpoint_columns) {
        contents += `    ${checkpoint_column},\n`;
      }
      contents += "  ])\n";
      contents += "};\n";

      if (!handle) {
        handle = await window.showSaveFilePicker({ suggestedName: "level.js" });
      }
      const writable = await handle.createWritable();
      await writable.write(contents);
      await writable.close();
    }

    function add_block(column, row) {
      let i = 0;
      while (blocks.get(i)) {
        i++;
      }
      blocks.set(i, { column: column, row: row });
    }

    function add_current_state_to_history() {
      const now = performance.now();
      if (history.length === 1) {
        current_history_transition_started_at = now;
      }
      history.push(structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns }));
    }

    function reset_to_edit_data() {
      const data = structuredClone(edit_data);
      player.column = find_prev_or_same_checkpoint_column(player.column);
      blocks = data.blocks;
      checkpoint_columns = data.checkpoint_columns;
    }

    function update_edit_data() {
      edit_data = structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns });
    }

    reset_to_edit_data();
    add_current_state_to_history();

    function in_bounds(column, row) {
      return column >= 0 && row >= 0 && row < grid_height;
    }

    function move_player(column_diff, row_diff) {
      const target_column = player.column + column_diff;
      const target_row = player.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        let can_move_to_space = true;
        for (const block of blocks.values()) {
          if (block.row === target_row && block.column === target_column) {
            const block_target_column = block.column + column_diff;
            const block_target_row = block.row + row_diff;
            let can_move_block = in_bounds(block_target_column, block_target_row);
            can_move_to_space = false;
            for (const other of blocks.values()) {
              if (other.column === block_target_column && other.row === block_target_row) {
                can_move_block = false;
                break;
              }
            }
            for (const checkpoint_column of checkpoint_columns) {
              if (checkpoint_column === block_target_column) {
                can_move_block = false;
                break;
              }
            }
            if (can_move_block) {
              block.column = block_target_column;
              block.row = block_target_row;
              can_move_to_space = true;
              break;
            }
          }
        }
        if (can_move_to_space) {
          player.column = target_column;
          player.row = target_row;
        }
      }
    }

    function move_cursor(column_diff, row_diff) {
      const target_column = cursor.column + column_diff;
      const target_row = cursor.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        cursor.column = target_column;
        cursor.row = target_row;
      }
    }

    function find_prev_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column < column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_prev_or_same_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column <= column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_next_checkpoint_column(column) {
      let next_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column > next_checkpoint_column) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      for (const checkpoint_column of checkpoint_columns) {
        if ((checkpoint_column > column && checkpoint_column < next_checkpoint_column) || next_checkpoint_column === 0) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      return next_checkpoint_column;
    }

    document.addEventListener('keydown', async ev => {
      switch (mode) {
        case 'play':
          // Since there is plenty of opportunity to make unfixable mistakes, we
          // want each key press to be intentional. Toward that end, if the key is
          // being held down, we only do one move at a time (which allows the user to
          // move smoothly by holding down a key). But if the key is not being
          // held, then it was probably hit repeatedly on purpose, which means we can
          // allow going ahead by more than one move (which allows the user to not
          // have to wait for the animation to finish before pressing the key for
          // the next move).
          if (history.length < 5 && !ev.repeat || history.length < 2) {
            if (ev.shiftKey) {
              switch (ev.key) {
                case 'ArrowLeft':
                  history = [];
                  add_current_state_to_history();
                  const prev_checkpoint_column = find_prev_checkpoint_column(player.column);
                  reset_to_edit_data();
                  viewport = { 
                    state: 'moving',
                    base: viewport_left,
                    target: get_viewport_left_target(prev_checkpoint_column, prev_checkpoint_column, 1),
                    started_at: performance.now()
                  };
                  player.column = prev_checkpoint_column;
                  break;
                case 'ArrowRight':
                  history = [];
                  add_current_state_to_history();
                  const next_checkpoint_column = find_next_checkpoint_column(player.column);
                  reset_to_edit_data();
                  viewport = {
                    state: 'moving',
                    base: viewport_left,
                    target: get_viewport_left_target(next_checkpoint_column, next_checkpoint_column, 1),
                    started_at: performance.now()
                  };
                  player.column = next_checkpoint_column;
                  break;
              }
            } else {
              switch (ev.key) {
                case 'ArrowLeft':
                  move_player(-1, 0);
                  break;
                case 'ArrowRight':
                  move_player(1, 0);
                  break;
                case 'ArrowUp':
                  move_player(0, -1);
                  break;
                case 'ArrowDown':
                  move_player(0, 1);
                  break;
                case 'm':
                  reset_to_edit_data();
                  mode = 'edit';
                  break;
              }
            }
            add_current_state_to_history();
          }
          break;
        case 'edit':
          if (ev.shiftKey) {
            switch (ev.key) {
              case 'ArrowLeft':
                cursor.column = find_prev_checkpoint_column(cursor.column);
                break;
              case 'ArrowRight':
                cursor.column = find_next_checkpoint_column(cursor.column);
                break;
            }
          } else {
            switch (ev.key) {
              case 'ArrowLeft':
                move_cursor(-1, 0);
                break;
              case 'ArrowRight':
                move_cursor(1, 0);
                break;
              case 'ArrowUp':
                move_cursor(0, -1);
                break;
              case 'ArrowDown':
                move_cursor(0, 1);
                break;
              case 'm':
                reset_to_edit_data();
                let history = [];
                add_current_state_to_history();
                mode = 'play';
                break;
              case 'b':
                let found_block = false;
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column && block.row === cursor.row) {
                    found_block = true;
                    blocks.delete(key);
                    break;
                  }
                }
                if (!found_block) {
                  add_block(cursor.column, cursor.row);
                }
                break;
              case 'c':
                if (checkpoint_columns.has(cursor.column)) {
                  checkpoint_columns.delete(cursor.column);
                } else {
                  let can_add_checkpoint_column = true;
                  for (const block of blocks.values()) {
                    if (cursor.column === block.column) {
                      can_add_checkpoint_column = false;
                    }
                  }
                  if (can_add_checkpoint_column) {
                    checkpoint_columns.add(cursor.column);
                  }
                }
                break;
              case 'i':
                for (const block of blocks.values()) {
                  if (block.column >= cursor.column) {
                    block.column += 1;
                  }
                }
                const new_checkpoint_columns = new Set();
                for (const checkpoint_column of checkpoint_columns) {
                  if (checkpoint_column >= cursor.column) {
                    new_checkpoint_columns.add(checkpoint_column + 1);
                  } else {
                    new_checkpoint_columns.add(checkpoint_column);
                  }
                }
                checkpoint_columns = new_checkpoint_columns;
                break;
              case 'd':
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column) {
                    blocks.delete(key);
                  } else if (block.column > cursor.column) {
                    block.column -= 1;
                  }
                }
                const new_checkpoint_columns2 = new Set();
                for (const checkpoint_column of checkpoint_columns) {
                  if (checkpoint_column > cursor.column) {
                    new_checkpoint_columns2.add(checkpoint_column - 1);
                  } else if (checkpoint_column !== cursor.column) {
                    new_checkpoint_columns2.add(checkpoint_column);
                  }
                }
                checkpoint_columns = new_checkpoint_columns2;
                break;
              case 's':
                await save_edit_data();
                break;
            }
          }
          update_edit_data();
          break;
      }
    });

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function get_viewport_left_target(from_column, to_column, lerp_remainder) {
      const player_x = Math.floor(grid_square_size * lerp(from_column, to_column, lerp_remainder));
      const viewport_left_start = Math.floor(grid_square_size * lerp(find_prev_or_same_checkpoint_column(from_column), find_prev_or_same_checkpoint_column(to_column), lerp_remainder));
      const viewport_left_end = Math.floor(grid_square_size * lerp(find_next_checkpoint_column(from_column), find_next_checkpoint_column(to_column), lerp_remainder)) - (grid_width - 1) * grid_square_size;
      return Math.max(viewport_left_start, Math.min(viewport_left_end, player_x - viewport_left_min));
    }

    function render_play() {
      let now = performance.now();
      const delta = now - current_history_transition_started_at;
      const lerp_t = delta / step_duration;
      const lerp_floor = Math.floor(lerp_t);
      const lerp_remainder = lerp_t - lerp_floor;
      const from = history[Math.min(history.length - 1, lerp_floor)];
      const to = history[Math.min(history.length - 1, lerp_floor + 1)]; 
      const viewport_left_target = get_viewport_left_target(from.player.column, to.player.column, lerp_remainder);

      switch (viewport.state) {
        case 'idle':
          if (viewport_left_target < viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: -0.2, started_at: now };
          } else if (viewport_left_target > viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: 0.2, started_at: now };
          }
          break;
        case 'tracking':
          const new_viewport_left = Math.floor(lerp(viewport.base, viewport.base + viewport.vector, now - viewport.started_at));
          if ((viewport.vector > 0 && new_viewport_left > viewport_left_target) || (viewport.vector < 0 && new_viewport_left < viewport_left_target)) {
            if ((viewport.vector > 0 && viewport_left < viewport_left_target) || (viewport.vector < 0 && viewport_left > viewport_left_target)) {
              viewport_left = viewport_left_target;
            }
            viewport = { state: 'idle' };
          } else {
            viewport_left = new_viewport_left;
          }
          break;
        case 'moving':
          viewport_left = Math.floor(lerp(viewport.base, viewport.target, (now - viewport.started_at) / 400.0));
          if ((viewport.target > viewport.base && viewport_left > viewport.target) || (viewport.target <= viewport.base && viewport_left < viewport.target)) {
            viewport_left = viewport.target;
            viewport = { state: 'idle' };
          }
          break;
      }

      ctx.translate(-viewport_left, 0);

      ctx.fillStyle = '#4d7c0f';
      for (const key of checkpoint_columns) {
        ctx.fillRect(grid_square_size * key, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(
        Math.floor(grid_square_size * lerp(from.player.column, to.player.column, lerp_remainder)),
        grid_square_size * lerp(from.player.row, to.player.row, lerp_remainder),
        grid_square_size, grid_square_size);

      ctx.fillStyle = '#a8a29e';
      for (const [key, to_block] of to.blocks) {
        const from_block = from.blocks.get(key);
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        ctx.fillRect(grid_square_size * column, grid_square_size * row, grid_square_size, grid_square_size);
      }

      if (history.length > 1 && lerp_t > 1) {
        history.shift(Math.max(0, Math.min(history.length - 1, lerp_floor)));
        current_history_transition_started_at = now - lerp_remainder;
      }
    }

    function render_edit() {
      const translate_x = Math.max(0, Math.floor(cursor.column * grid_square_size - viewport_left_min));
      ctx.translate(-translate_x, 0);

      ctx.fillStyle = '#4d7c0f';
      for (const key of checkpoint_columns) {
        ctx.fillRect(grid_square_size * key, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#a8a29e';
      for (const block of blocks.values()) {
        ctx.fillRect(grid_square_size * block.column, grid_square_size * block.row, grid_square_size, grid_square_size);
      }

      ctx.strokeStyle = '#059669';
      ctx.lineWidth = 2;
      ctx.strokeRect(grid_square_size * cursor.column, grid_square_size * cursor.row, grid_square_size, grid_square_size);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = '20px sans-serif';
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(`Editing Level`, 10, 30);
      ctx.fillText(`Cursor: column ${cursor.column}, row ${cursor.row}`, 10, 60);
    }

    function render() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#44403c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      switch (mode) {
        case 'play':
          render_play();
          break;
        case 'edit':
          render_edit();
          break;
      }

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

  </script>
</body>
</html>
