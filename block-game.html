<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: auto;
      width: 1200px;
    }
    #game {
      display: block;
      background: #fff;
      width: 1200px;
      height: 540px;
      margin: auto;
    }

    kbd {
      display: inline-block;
      margin: 0 0.1em;
      font-family: ui-monospace, "SF Mono", "Consolas", monospace;
      font-size: 0.5em;
      color: #333;
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 1px 0 #ccc;
      vertical-align: middle;
      user-select: none;  /* not interactive */
    }

    p, li {
      font-size: 1.5em;
    }
  </style>
</head>
<body>
  <p>Below is a game in which you must navigate a red square from the start of
  the world to the end through a labyrinth of blocks. The challenge is to
  discover the rules of the world and solve the puzzle presented by each
  level. The joy is in solving the puzzles, so you we do not force you to
  unlock anything; you can skip between all the levels however much you
  like.</p>

  <p>Controls:</p>

  <ul>
    <li><kbd>Up</kbd>, <kbd>Down</kbd>, <kbd>Left</kbd>, <kbd>Right</kbd>: Move the red square in the specified direction.</li>
    <li><kbd>Shift</kbd>+<kbd>Left</kbd>: Move the red square <em>backward</em> to
      the nearest green column and reset the state of the world. This is useful
      especially if you get make a mistake and need to start the level over.</li>
    <li><kbd>Shift</kbd>+<kbd>Right</kbd>: Move the red square <em>forward</em> to
      the nearest green column and reset the state of the world. This is useful
      for skipping over levels that you can't figure out.</li>
  </ul>

  <p>As you might guess from the controls, this game is designed to be played
  from a computer; it probably isn't playable from a mobile device.</p>

  <canvas id="game" width="1200" height="540"></canvas>
  <script src="level.js"></script>
  <script>
    const grid_square_size = 60;
    const grid_height = 9;
    const grid_width = 20;
    const step_duration = 200;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let player = { column: 0, row: 0 };
    let blocks = new Map();
    let checkpoint_columns = new Set();
    let history = [];
    const cursor = { column: 0, row: 0 };
    let current_history_transition_started_at = 0;
    let mode = 'play';

    let viewport = { state: 'idle' };
    const viewport_left_min = grid_width / 2 * grid_square_size;
    let viewport_left = 0;
    let handle;

    async function save_edit_data() {
      let contents = "";
      contents += "let edit_data = {\n";
      contents += "  blocks: new Map([\n";
      for (const [key, value] of edit_data.blocks) {
        contents += `    [ ${key}, { column: ${value.column}, row: ${value.row}`;
        if (value.shape) {
          contents += `, shape: ${value.shape}`;
        }
        contents += ` } ],\n`;
      }
      contents += "  ]),\n";
      contents += "  player: { column: 0, row: 0 },\n";
      contents += "  checkpoint_columns: new Set([\n";
      for (const checkpoint_column of edit_data.checkpoint_columns) {
        contents += `    ${checkpoint_column},\n`;
      }
      contents += "  ])\n";
      contents += "};\n";

      if (!handle) {
        handle = await window.showSaveFilePicker({ suggestedName: "level.js" });
      }
      const writable = await handle.createWritable();
      await writable.write(contents);
      await writable.close();
    }

    function add_block(column, row) {
      let i = 0;
      while (blocks.get(i)) {
        i++;
      }
      blocks.set(i, { column: column, row: row });
    }

    function add_block_with_shape(column, row, shape) {
      let i = 0;
      while (blocks.get(i)) {
        i++;
      }
      blocks.set(i, { column: column, row: row, shape: shape });
    }

    function add_current_state_to_history() {
      const now = performance.now();
      if (history.length === 1) {
        current_history_transition_started_at = now;
      }
      history.push(structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns }));
    }

    function reset_to_edit_data() {
      const data = structuredClone(edit_data);
      player.column = find_prev_or_same_checkpoint_column(player.column);
      blocks = data.blocks;
      checkpoint_columns = data.checkpoint_columns;
    }

    function update_edit_data() {
      edit_data = structuredClone({ player: player, blocks: blocks, checkpoint_columns: checkpoint_columns });
    }

    reset_to_edit_data();
    add_current_state_to_history();

    function in_bounds(column, row) {
      return column >= 0 && row >= 0 && row < grid_height;
    }

    function can_move_block(block, column_diff, row_diff) {
      const target_column = block.column + column_diff;
      const target_row = block.row + row_diff;
      let can_move = in_bounds(target_column, target_row);
      for (const other of blocks.values()) {
        if (other.column === target_column && other.row === target_row) {
          if (block.shape) {
            can_move = other.shape === block.shape;
          } else {
            can_move = false;
          }
          break;
        }
      }
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column === target_column) {
          can_move = false;
          break;
        }
      }
      console.log('can move block', block, column_diff, row_diff, can_move);
      return can_move;
    }

    function move_player(column_diff, row_diff) {
      const target_column = player.column + column_diff;
      const target_row = player.row + row_diff;
      const prev_checkpoint_column = find_prev_or_same_checkpoint_column(player.column);
      const next_checkpoint_column = find_next_checkpoint_column(player.column);
      if (in_bounds(target_column, target_row)) {
        let can_move_to_space = true;
        for (const block of blocks.values()) {
          if (block.row === target_row && block.column === target_column) {
            can_move_to_space = false;
            if (can_move_block(block, column_diff, row_diff)) {
              let can_move_blocks = true;
              let blocks_to_move = [];
              if (block.shape) {
                for (const block_with_shape of blocks.values()) {
                  if (block_with_shape.column > prev_checkpoint_column && block_with_shape.column < next_checkpoint_column && block_with_shape.shape === block.shape) {
                    if (!can_move_block(block_with_shape, column_diff, row_diff)) {
                      can_move_blocks = false;
                      break;
                    }
                    blocks_to_move.push(block_with_shape);
                  }
                }
              } else {
                blocks_to_move.push(block);
              }
              if (can_move_blocks) {
                can_move_to_space = true;
                for (const block_to_move of blocks_to_move) {
                  block_to_move.column += column_diff;
                  block_to_move.row += row_diff;
                }
              }
            }
            break;
          }
        }
        if (can_move_to_space) {
          player.column = target_column;
          player.row = target_row;
        }
      }
    }

    function move_cursor(column_diff, row_diff) {
      const target_column = cursor.column + column_diff;
      const target_row = cursor.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        cursor.column = target_column;
        cursor.row = target_row;
      }
    }

    function find_prev_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column < column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_prev_or_same_checkpoint_column(column) {
      let prev_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column <= column && checkpoint_column > prev_checkpoint_column) {
          prev_checkpoint_column = checkpoint_column;
        }
      }
      return prev_checkpoint_column;
    }

    function find_next_checkpoint_column(column) {
      let next_checkpoint_column = 0;
      for (const checkpoint_column of checkpoint_columns) {
        if (checkpoint_column > next_checkpoint_column) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      for (const checkpoint_column of checkpoint_columns) {
        if ((checkpoint_column > column && checkpoint_column < next_checkpoint_column) || next_checkpoint_column === 0) {
          next_checkpoint_column = checkpoint_column;
        }
      }
      return next_checkpoint_column;
    }

    function toggle_shape_block(shape) {
      let found_block = false;
      for (const [key, block] of blocks) {
        if (block.column === cursor.column && block.row === cursor.row) {
          found_block = true;
          blocks.delete(key);
          break;
        }
      }
      if (!found_block) {
        add_block_with_shape(cursor.column, cursor.row, shape);
      }
    }

    document.addEventListener('keydown', async ev => {
      switch (mode) {
        case 'play':
          // Since there is plenty of opportunity to make unfixable mistakes, we
          // want each key press to be intentional. Toward that end, if the key is
          // being held down, we only do one move at a time (which allows the user to
          // move smoothly by holding down a key). But if the key is not being
          // held, then it was probably hit repeatedly on purpose, which means we can
          // allow going ahead by more than one move (which allows the user to not
          // have to wait for the animation to finish before pressing the key for
          // the next move).
          if (history.length < 5 && !ev.repeat || history.length < 2) {
            if (ev.shiftKey) {
              switch (ev.key) {
                case 'ArrowLeft':
                  history = [];
                  add_current_state_to_history();
                  const prev_checkpoint_column = find_prev_checkpoint_column(player.column);
                  reset_to_edit_data();
                  player.column = prev_checkpoint_column;
                  break;
                case 'ArrowRight':
                  history = [];
                  add_current_state_to_history();
                  const next_checkpoint_column = find_next_checkpoint_column(player.column);
                  reset_to_edit_data();
                  player.column = next_checkpoint_column;
                  break;
              }
            } else {
              switch (ev.key) {
                case 'ArrowLeft':
                  move_player(-1, 0);
                  break;
                case 'ArrowRight':
                  move_player(1, 0);
                  break;
                case 'ArrowUp':
                  move_player(0, -1);
                  break;
                case 'ArrowDown':
                  move_player(0, 1);
                  break;
                case 'm':
                  reset_to_edit_data();
                  mode = 'edit';
                  break;
              }
            }
            add_current_state_to_history();
          }
          break;
        case 'edit':
          if (ev.shiftKey) {
            switch (ev.key) {
              case 'ArrowLeft':
                cursor.column = find_prev_checkpoint_column(cursor.column);
                break;
              case 'ArrowRight':
                cursor.column = find_next_checkpoint_column(cursor.column);
                break;
            }
          } else {
            switch (ev.key) {
              case 'ArrowLeft':
                move_cursor(-1, 0);
                break;
              case 'ArrowRight':
                move_cursor(1, 0);
                break;
              case 'ArrowUp':
                move_cursor(0, -1);
                break;
              case 'ArrowDown':
                move_cursor(0, 1);
                break;
              case 'm':
                reset_to_edit_data();
                let history = [];
                add_current_state_to_history();
                mode = 'play';
                break;
              case 'b':
                let found_block = false;
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column && block.row === cursor.row) {
                    found_block = true;
                    blocks.delete(key);
                    break;
                  }
                }
                if (!found_block) {
                  add_block(cursor.column, cursor.row);
                }
                break;
              case '3':
                toggle_shape_block(3);
                break;
              case '4':
                toggle_shape_block(4);
                break;
              case '5':
                toggle_shape_block(5);
                break;
              case '6':
                toggle_shape_block(6);
                break;
              case '7':
                toggle_shape_block(15);
                break;
              case 'c':
                if (checkpoint_columns.has(cursor.column)) {
                  checkpoint_columns.delete(cursor.column);
                } else {
                  let can_add_checkpoint_column = true;
                  for (const block of blocks.values()) {
                    if (cursor.column === block.column) {
                      can_add_checkpoint_column = false;
                    }
                  }
                  if (can_add_checkpoint_column) {
                    checkpoint_columns.add(cursor.column);
                  }
                }
                break;
              case 'i':
                for (const block of blocks.values()) {
                  if (block.column >= cursor.column) {
                    block.column += 1;
                  }
                }
                const new_checkpoint_columns = new Set();
                for (const checkpoint_column of checkpoint_columns) {
                  if (checkpoint_column >= cursor.column) {
                    new_checkpoint_columns.add(checkpoint_column + 1);
                  } else {
                    new_checkpoint_columns.add(checkpoint_column);
                  }
                }
                checkpoint_columns = new_checkpoint_columns;
                break;
              case 'd':
                for (const [key, block] of blocks) {
                  if (block.column === cursor.column) {
                    blocks.delete(key);
                  } else if (block.column > cursor.column) {
                    block.column -= 1;
                  }
                }
                const new_checkpoint_columns2 = new Set();
                for (const checkpoint_column of checkpoint_columns) {
                  if (checkpoint_column > cursor.column) {
                    new_checkpoint_columns2.add(checkpoint_column - 1);
                  } else if (checkpoint_column !== cursor.column) {
                    new_checkpoint_columns2.add(checkpoint_column);
                  }
                }
                checkpoint_columns = new_checkpoint_columns2;
                break;
              case 's':
                await save_edit_data();
                break;
            }
          }
          update_edit_data();
          break;
      }
    });

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function get_viewport_left_target(from_column, to_column, lerp_remainder) {
      const player_x = Math.floor(grid_square_size * lerp(from_column, to_column, lerp_remainder));
      const viewport_left_start = Math.floor(grid_square_size * lerp(find_prev_or_same_checkpoint_column(from_column), find_prev_or_same_checkpoint_column(to_column), lerp_remainder));
      const viewport_left_end = Math.floor(grid_square_size * lerp(find_next_checkpoint_column(from_column), find_next_checkpoint_column(to_column), lerp_remainder)) - (grid_width - 1) * grid_square_size;
      return Math.max(viewport_left_start, Math.min(viewport_left_end, player_x - viewport_left_min));
    }

    const shape_radius = grid_square_size / 3;
    function fill_shape(column, row, shape) {
      const cx = grid_square_size * column + grid_square_size / 2;
      const cy = grid_square_size * row + grid_square_size / 2;
      ctx.beginPath();
      for (let i = 0; i < shape; i += 1) {
        const angle = 2 * Math.PI / shape * i - Math.PI / 2;
        const x = cx + Math.cos(angle) * shape_radius;
        const y = cy + Math.sin(angle) * shape_radius;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.fill();
    }

    function render_play() {
      let now = performance.now();
      const delta = now - current_history_transition_started_at;
      const lerp_t = delta / step_duration;
      const lerp_floor = Math.floor(lerp_t);
      const lerp_remainder = lerp_t - lerp_floor;
      const from = history[Math.min(history.length - 1, lerp_floor)];
      const to = history[Math.min(history.length - 1, lerp_floor + 1)]; 
      const viewport_left_target = get_viewport_left_target(from.player.column, to.player.column, lerp_remainder);

      switch (viewport.state) {
        case 'idle':
          const current_checkpoint_column = find_prev_or_same_checkpoint_column(from.player.column);
          const new_checkpoint_column = find_prev_or_same_checkpoint_column(to.player.column);
          let speed = 0.2;
          if (current_checkpoint_column !== new_checkpoint_column) {
            speed = 2;
          }
          if (viewport_left_target < viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: -1 * speed, started_at: now };
          } else if (viewport_left_target > viewport_left) {
            viewport = { state: 'tracking', base: viewport_left, vector: speed, started_at: now };
          }
          break;
        case 'tracking':
          const new_viewport_left = Math.floor(lerp(viewport.base, viewport.base + viewport.vector, now - viewport.started_at));
          if ((viewport.vector > 0 && new_viewport_left > viewport_left_target) || (viewport.vector < 0 && new_viewport_left < viewport_left_target)) {
            if ((viewport.vector > 0 && viewport_left < viewport_left_target) || (viewport.vector < 0 && viewport_left > viewport_left_target)) {
              viewport_left = viewport_left_target;
            }
            viewport = { state: 'idle' };
          } else {
            viewport_left = new_viewport_left;
          }
          break;
      }

      ctx.translate(-viewport_left, 0);

      ctx.fillStyle = '#4d7c0f';
      for (const key of checkpoint_columns) {
        ctx.fillRect(grid_square_size * key, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(
        Math.floor(grid_square_size * lerp(from.player.column, to.player.column, lerp_remainder)),
        grid_square_size * lerp(from.player.row, to.player.row, lerp_remainder),
        grid_square_size, grid_square_size);

      ctx.fillStyle = '#a8a29e';
      for (const [key, to_block] of to.blocks) {
        const from_block = from.blocks.get(key);
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        ctx.fillRect(grid_square_size * column, grid_square_size * row, grid_square_size, grid_square_size);
      }

      ctx.fillStyle = '#fcd34d';
      for (const [key, to_block] of to.blocks) {
        const from_block = from.blocks.get(key);
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        fill_shape(column, row, to_block.shape);
      }

      if (history.length > 1 && lerp_t > 1) {
        history.shift(Math.max(0, Math.min(history.length - 1, lerp_floor)));
        current_history_transition_started_at = now - lerp_remainder;
      }
    }

    function render_edit() {
      const translate_x = Math.max(0, Math.floor(cursor.column * grid_square_size - viewport_left_min));
      ctx.translate(-translate_x, 0);

      ctx.fillStyle = '#4d7c0f';
      for (const key of checkpoint_columns) {
        ctx.fillRect(grid_square_size * key, 0, grid_square_size, grid_height * grid_square_size);
      }

      ctx.fillStyle = '#a8a29e';
      for (const block of blocks.values()) {
        ctx.fillRect(grid_square_size * block.column, grid_square_size * block.row, grid_square_size, grid_square_size);
      }

      ctx.fillStyle = '#fcd34d';
      for (const block of blocks.values()) {
        if (block.shape) {
          fill_shape(block.column, block.row, block.shape);
        }
      }

      ctx.strokeStyle = '#059669';
      ctx.lineWidth = 2;
      ctx.strokeRect(grid_square_size * cursor.column, grid_square_size * cursor.row, grid_square_size, grid_square_size);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = '20px sans-serif';
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(`Editing Level`, 10, 30);
      ctx.fillText(`Cursor: column ${cursor.column}, row ${cursor.row}`, 10, 60);
    }

    function render() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#44403c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      switch (mode) {
        case 'play':
          render_play();
          break;
        case 'edit':
          render_edit();
          break;
      }

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

  </script>
</body>
</html>
