<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Block Game</title>
  <style>
    :root, html, body {
      margin: 0px;
      padding: 0px;
    }
    body {
      margin: 0px auto;
    }
    #game {
      display: block;
      background: #fff;
      width: 1200px;
      height: 480px;
      margin: 0px auto;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1200" height="480"></canvas>
  <script>
    const grid_square_size = 60;
    const grid_height = 8;
    const grid_width = 20;
    const step_duration = 200;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let player = { column: 0, row: 0 };
    let blocks = [];
    const history = [];
    const cursor = { column: 0, row: 0 };
    let current_history_transition_started_at = 0;
    let mode = 'play';

    let viewport_moving = false;
    let viewport_moving_base = 0;
    let viewport_moving_target = 0;
    let viewport_moving_started_at = 0;
    const viewport_left_min =  grid_width / 2 * grid_square_size;
    let viewport_left = 0;

    let edit_data = {
      blocks: {
        0: { column: 9, row: 0 },
        1: { column: 9, row: 1 },
        2: { column: 9, row: 2 },
        3: { column: 9, row: 3 },
        4: { column: 9, row: 4 },
        5: { column: 9, row: 5 },
        6: { column: 9, row: 6 },
        7: { column: 9, row: 7 },
        8: { column: 10, row: 7 },
        9: { column: 10, row: 6 },
        10: { column: 10, row: 5 },
        11: { column: 10, row: 2 },
        12: { column: 10, row: 1 },
        13: { column: 10, row: 0 },
        14: { column: 11, row: 0 },
        15: { column: 13, row: 0 },
        16: { column: 12, row: 0 },
        17: { column: 17, row: 1 },
        18: { column: 16, row: 1 },
        19: { column: 14, row: 1 },
        20: { column: 11, row: 6 },
        21: { column: 11, row: 7 },
        22: { column: 12, row: 7 },
        23: { column: 12, row: 6 },
        24: { column: 12, row: 4 },
        25: { column: 12, row: 3 },
        26: { column: 12, row: 2 },
        27: { column: 13, row: 2 },
        28: { column: 13, row: 3 },
        29: { column: 13, row: 6 },
        30: { column: 13, row: 7 },
        31: { column: 14, row: 7 },
        32: { column: 14, row: 6 },
        33: { column: 14, row: 4 },
        34: { column: 14, row: 3 },
        35: { column: 14, row: 2 },
        36: { column: 15, row: 2 },
        37: { column: 15, row: 3 },
        38: { column: 15, row: 4 },
        39: { column: 15, row: 6 },
        40: { column: 15, row: 7 },
        41: { column: 16, row: 7 },
        42: { column: 16, row: 6 },
        43: { column: 16, row: 4 },
        44: { column: 16, row: 2 },
        45: { column: 17, row: 2 },
        46: { column: 17, row: 3 },
        47: { column: 17, row: 5 },
        48: { column: 17, row: 6 },
        49: { column: 17, row: 7 },
        50: { column: 18, row: 7 },
        51: { column: 18, row: 6 },
        52: { column: 18, row: 5 },
        53: { column: 19, row: 5 },
        54: { column: 19, row: 6 },
        55: { column: 19, row: 7 },
        56: { column: 8, row: 3 },
        57: { column: 8, row: 2 },
        58: { column: 8, row: 1 },
        59: { column: 8, row: 0 },
        60: { column: 8, row: 5 },
        61: { column: 8, row: 6 },
        62: { column: 8, row: 7 },
        63: { column: 18, row: 3 },
        64: { column: 18, row: 2 },
        65: { column: 18, row: 0 },
        66: { column: 19, row: 3 },
        67: { column: 19, row: 0 },
        68: { column: 7, row: 6 },
        69: { column: 6, row: 6 },
        70: { column: 7, row: 4 },
        71: { column: 6, row: 5 },
        72: { column: 2, row: 0 },
        73: { column: 2, row: 1 },
        74: { column: 3, row: 2 },
        75: { column: 4, row: 0 },
        76: { column: 6, row: 1 },
        77: { column: 6, row: 3 },
        78: { column: 6, row: 2 },
        79: { column: 1, row: 1 },
        80: { column: 1, row: 2 },
        81: { column: 1, row: 3 },
        82: { column: 1, row: 4 },
        83: { column: 1, row: 5 },
        84: { column: 1, row: 6 },
        85: { column: 2, row: 6 },
        86: { column: 3, row: 6 },
        87: { column: 4, row: 6 },
        88: { column: 5, row: 4 },
        89: { column: 4, row: 4 },
        90: { column: 3, row: 4 },
        91: { column: 4, row: 2 },
        92: { column: 3, row: 3 },
        93: { column: 4, row: 3 },
        94: { column: 5, row: 0 },
        95: { column: 5, row: 3 }
      },
      player: { column: 0, row: 0 }
    };

    function add_block(column, row) {
      let i = 0;
      while (blocks[i]) {
        i++;
      }
      blocks[i] = { column: column, row: row };
    }

    function reset_to_edit_data() {
      const data = structuredClone(edit_data);
      player = data.player;
      blocks = data.blocks;
    }

    function add_current_state_to_history() {
      const now = performance.now();
      if (history.length === 1) {
        current_history_transition_started_at = now;
      }
      history.push(structuredClone({ player: player, blocks: blocks }));
    }

    reset_to_edit_data();
    add_current_state_to_history();

    function in_bounds(column, row) {
      return column >= 0 && row >= 0 && row < grid_height;
    }

    function move_player(column_diff, row_diff) {
      const target_column = player.column + column_diff;
      const target_row = player.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        let can_move_to_space = true;
        for (const key in blocks) {
          const block = blocks[key];
          if (block.row === target_row && block.column === target_column) {
            const block_target_column = block.column + column_diff;
            const block_target_row = block.row + row_diff;
            let can_move_block = in_bounds(block_target_column, block_target_row);
            can_move_to_space = false;
            for (const other_key in blocks) {
              const other = blocks[other_key];
              if (other.column === block_target_column && other.row === block_target_row) {
                can_move_block = false;
                break;
              }
            }
            if (can_move_block) {
              block.column = block_target_column;
              block.row = block_target_row;
              can_move_to_space = true;
              break;
            }
          }
        }
        if (can_move_to_space) {
          player.column = target_column;
          player.row = target_row;
        }
      }
    }

    function move_cursor(column_diff, row_diff) {
      const target_column = cursor.column + column_diff;
      const target_row = cursor.row + row_diff;
      if (in_bounds(target_column, target_row)) {
        cursor.column = target_column;
        cursor.row = target_row;
      }
    }

    document.addEventListener('keydown', ev => {
      // Since there is plenty of opportunity to make unfixable mistakes, we
      // want each key press to be intentional. Toward that end, if the key is
      // being held down, we only do one move at a time (which allows the user to
      // move smoothly by holding down a key). But if the key is not being
      // held, then it was probably hit repeatedly on purpose, which means we can
      // allow going ahead by more than one move (which allows the user to not
      // have to wait for the animation to finish before pressing the key for
      // the next move).
      if (history.length < 5 && !ev.repeat || history.length < 2) {
        switch (mode) {
          case 'play':
            switch (ev.key) {
              case 'ArrowLeft':
                move_player(-1, 0);
                break;
              case 'ArrowRight':
                move_player(1, 0);
                break;
              case 'ArrowUp':
                move_player(0, -1);
                break;
              case 'ArrowDown':
                move_player(0, 1);
                break;
              case 'm':
                reset_to_edit_data();
                mode = 'edit';
                break;
              case 'r':
                reset_to_edit_data();
                break;
            }
            break;
          case 'edit':
            switch (ev.key) {
              case 'ArrowLeft':
                move_cursor(-1, 0);
                break;
              case 'ArrowRight':
                move_cursor(1, 0);
                break;
              case 'ArrowUp':
                move_cursor(0, -1);
                break;
              case 'ArrowDown':
                move_cursor(0, 1);
                break;
              case 'm':
                edit_data = structuredClone({ player: player, blocks: blocks });
                const data = structuredClone(edit_data);
                player = data.player;
                blocks = data.blocks;
                mode = 'play';
                break;
              case 'b':
                let found_block = false;
                for (let key in blocks) {
                  let block = blocks[key];
                  if (block.column === cursor.column && block.row === cursor.row) {
                    found_block = true;
                    delete blocks[key];
                    break;
                  }
                }
                if (!found_block) {
                  add_block(cursor.column, cursor.row);
                }
                break;
            }
            break;
        }
        add_current_state_to_history();
      }
    });

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function loop() {
      let now = performance.now();
      const delta = now - current_history_transition_started_at;
      const lerp_t = delta / step_duration;
      const lerp_floor = Math.floor(lerp_t);
      const lerp_remainder = lerp_t - lerp_floor;
      const from = history[Math.min(history.length - 1, lerp_floor)];
      const to = history[Math.min(history.length - 1, lerp_floor + 1)]; 

      const player_x = grid_square_size * lerp(from.player.column, to.player.column, lerp_remainder);
      if (viewport_moving) {
        viewport_left = lerp(viewport_moving_base, viewport_moving_target, now - viewport_moving_started_at);
        viewport_left = Math.floor(viewport_left);
        if (
          ((viewport_moving_target > viewport_moving_base) && viewport_left > player_x)
        || ((viewport_moving_target < viewport_moving_base) && viewport_left < player_x)) {
          viewport_left = player_x;
          viewport_moving = false;
        }
      } else {
        if (player_x < viewport_left) {
          viewport_moving = true;
          viewport_moving_base = viewport_left;
          viewport_moving_target = viewport_moving_base - 0.1;
          viewport_moving_started_at = now;
        } else if (player_x > viewport_left) {
          viewport_moving = true;
          viewport_moving_base = viewport_left;
          viewport_moving_target = viewport_moving_base + 0.1;
          viewport_moving_started_at = now;
        }
      }
      if (viewport_left < viewport_left_min) {
        viewport_left = viewport_left_min;
      }
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      translate_x = Math.min(0, grid_width / 2 * grid_square_size - viewport_left);
      ctx.translate(translate_x, 0);

      ctx.fillStyle = '#44403c';
      ctx.fillRect(-translate_x, 0, canvas.width, canvas.height);

      if (false) {
        ctx.strokeStyle = '#57534e';
        for (let r = 1; r < grid_height; r++) {
          ctx.beginPath();
          const y = r * grid_square_size;
          ctx.moveTo(0, y);
          ctx.lineTo(grid_width * grid_square_size, y);
          ctx.stroke();
        }

        for (let c = 1; c < grid_width; c++) {
          ctx.beginPath();
          const x = c * grid_square_size;
          ctx.moveTo(x, 0);
          ctx.lineTo(x, grid_height * grid_square_size);
          ctx.stroke();
        }
      }

      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(
        player_x,
        grid_square_size * lerp(from.player.row, to.player.row, lerp_remainder),
        grid_square_size, grid_square_size);

      for (const key in to.blocks) {
        const from_block = from.blocks[key];
        const to_block = to.blocks[key];
        ctx.fillStyle = '#a8a29e';
        let column = to_block.column;
        let row = to_block.row;
        if (from_block) {
          column = lerp(from_block.column, to_block.column, lerp_remainder);
          row = lerp(from_block.row, to_block.row, lerp_remainder)
        }
        ctx.fillRect(grid_square_size * column, grid_square_size * row, grid_square_size, grid_square_size);
      }

      switch (mode) {
        case 'play':
          break;
        case 'edit':
          ctx.strokeStyle = '#059669';
          ctx.lineWidth = 2;
          ctx.strokeRect(grid_square_size * cursor.column, grid_square_size * cursor.row, grid_square_size, grid_square_size);
          ctx.font = '20px sans-serif';
          ctx.fillStyle = '#e2e8f0';
          ctx.fillText('Editor', 10, 30);
          break;
      }

      if (history.length > 1 && lerp_t > 1) {
        history.shift(Math.max(0, Math.min(history.length - 1, lerp_floor)));
        current_history_transition_started_at = now - lerp_remainder;
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

  </script>
</body>
</html>
